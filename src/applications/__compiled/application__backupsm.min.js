/**
Systems OS - 0.0.1

Copyright (c) 2018 Isart Navarro Farell
License: MIT
*/
var backupsmApp = angular.module('backupsmApp', []);

(function () {
	"use strict";
	backupsmApp.run(['ApplicationsFactory', 'ServerFactory', 'backupsmFactory', 'modalFactory', function(ApplicationsFactory, ServerFactory, backupsmFactory, modalFactory) {

		ApplicationsFactory.registerApplication({
			id: "backupsm",
			ico: "hdd-o",
			name: "Backups Manager",
			menu: true,
			actions: true,
			style: "width:870px;height:600px;top:7%;left:10%;"
		});

		// Get restores
		ServerFactory
		.getConfigFile('applications/backupsm/restores.json', function (data) {
			return backupsmFactory.setRestores(data.data);
		}, function (data) {
			console.log("Error");
		});

		/*
		 * Register modals
		 */
        modalFactory.registerModal({
            modalId: "ESXiSelectable",
            templateUrl: "applications/backupsm/modals/ESXiSelectable.html",
            size: "sm",
            controllerAs: "esmC",
            controller: ['title', 'ESXihosts', '$uibModalInstance', function (title, ESXihosts, $uibModalInstance) {
                var _this = this;
                this.title = title;
                this.ESXihosts = ESXihosts;

                this.selectESXihost = function () {
                    $uibModalInstance.close(_this.selectedHost);
                };
            }]
        });

        modalFactory.registerModal({
            modalId: "recoveryWizard",
            templateUrl: "applications/backupsm/modals/recoveryWizard.html",
            size: "sm",
            controllerAs: "wmC",
            controller: ['title', 'data', '$uibModalInstance', 'ServerFactory', '$filter', function (title, data, $uibModalInstance, ServerFactory, $filter) {
                var _this = this;
                this.title = title;
                this.step = 1;
                this.data = data;

                this.vmName = data.vm.name;
                this.powerVM = false;

                this.getSnapshotName = function () {
                    return $filter('filter')(data.snapshots, {
                        "snapshot-instance-uuid": data.snapshot
                    })[0].name;
                };

                this.selectData = function () {
                    if ((!_this.selectedHost || !_this.selectedFolder || !_this.selectedPool) && _this.restoreType === "new") return _this.step = 3;

                    $uibModalInstance.close({
                        host: _this.selectedHost,
                        folder: _this.selectedFolder,
                        resource_pool: _this.selectedPool,
                        vm_name: _this.vmName,
                        vm_power_on: _this.powerVM,
                        restore_location: _this.restoreType,
                    });
                };

                /*
                 * Load Folders and Resource Pools
                 */
                this.loadESXidata = function () {
                    var modalInstanceText = openLittleModal('PLEASE WAIT', 'Connecting to vCenter...', '.modal-recovery-wizard', 'plain');

                    return ServerFactory.connectVcenter(_this.selectedHost.connection_address, _this.selectedHost.connection_credential).then(function (con) {
                        if (con.data.status === "error") throw new Error(con.data.data);

                        changeModalText('Getting data...', '.modal-recovery-wizard');

                        // Get VM folders in selected vCenter
                        return ServerFactory.callVcenter(_this.selectedHost.connection_address, '/rest/vcenter/folder?filter.type=VIRTUAL_MACHINE').then(function (data_folder) {
                            if (data_folder.data.status === "error") throw new Error(data_folder.data.data);
                            _this.data.folders = data_folder.data.data.response.value;

                            // Get Resource Pools from selected host
                            return ServerFactory.callVcenter(_this.selectedHost.connection_address, '/rest/vcenter/resource-pool').then(function (resource_pool) {
                                if (resource_pool.data.status === "error") throw new Error(resource_pool.data.data);

                                _this.data.resource_pools = resource_pool.data.data.response.value;

                                modalInstanceText.close();
                            });
                        });
                    });
                };

            }]
        });

	}]);
}());
(function () {
	"use strict";
	backupsmApp.controller('bmActionController', ['$scope', function ($scope) {

		var _this = this;
		var APPscope = $scope.$parent.$parent.$parent.$parent;

		/*
	     * ng-click functions
	     */
		this.newRestore = function () {
			APPscope.$broadcast('backupsm__new_restore');
		};

	}]);
}());
(function () {
	"use strict";
	backupsmApp.controller('bmBodyController', ['$rootScope', '$scope', '$filter', '$timeout', '$log', 'uuid', 'backupsmFactory', 'modalFactory', 'ApplicationsFactory', 'vmwareFactory', 'netappFactory',
		function ($rootScope, $scope, $filter, $timeout, $log, uuid, backupsmFactory, modalFactory, ApplicationsFactory, vmwareFactory, netappFactory) {

			var _this = this;

			this.viewSide = true;
			this.showNewBackupType = true;
			this.showRestore = false;
			this.restores = [];
			this.activeRestore = null;

			/*
			 * Bindings
			 */
			$scope.$watch(function(){
				return backupsmFactory.getRestores();
			}, function(newValue){
				_this.restores = newValue;
			});

			$scope.$watch(function(){
				return backupsmFactory.getActiveRestore();
			}, function(newValue){
				_this.activeRestore = newValue;
			});

			/*
			 * Called at backupsmActionController
			 */
			$scope.$on('backupsm__new_restore', function () {
				_this.showNewBackupType = true;
				_this.showRestore = false;
			});

			/*
			 * Returns restore data from active restore
			 */
			this.getActiveRestore = function () {
				return $filter('filter')(_this.restores, {uuid: _this.activeRestore})[0];
			};

			/*
			 * ---------------------
			 * Outside calls
			 * ---------------------
			 */

			/*
			 * Mount Restore Datastore from Storage Snapshot
			 */
			$scope.$on('backupsm__mount_restore_datastore', function (event, data) {
				console.log(data);

				data.type = "mount_restore_datastore";
				data.restore_name = "Datastore mount (" + data.volume["volume-id-attributes"].name + ")";
				data.uuid = uuid.v4();

				data.volume_junction = data.volume["volume-id-attributes"]["junction-path"];
				data.netapp_credential = data.storage.credential;
				data.netapp_host = data.storage.host;
				data.netapp_port = data.storage.port;
				data.netapp_nfs_ip = $filter('filter')(data.storage.netifaces, {
					vserver: data.vserver["vserver-name"],
					"current-node": data.volume["volume-id-attributes"].node
				});
				data.esxi_datastore_name = 'SysOS_' + data.volume_junction.substr(1);

				$log.debug("Backups Manager [%s] -> Received event [%s] -> Initializing mount of datastore [%s] from -> storage [%s], vserver [%s], snapshot [%s]", data.uuid, event.name, data.volume["volume-id-attributes"].name, data.netapp_host, data.vserver["vserver-name"], data.snapshot);

				backupsmFactory.setRestore(data);
				backupsmFactory.setActiveRestore(data.uuid);

                var modalInstance = modalFactory.openRegistredModal("ESXiSelectable", ".window--backupsm .window__main",
                    {
                        title: function () {
                            return "Select ESXi host";
                        },
                        ESXihosts: function () {
                            return data.ESXihosts;
                        }
                    }
                );
				modalInstance.result.then(function (res) {

					$log.debug("Backups Manager [%s] -> Received restore data from Modal -> esxi_host", data.uuid, res.host);

					data.esxi_credential = res.connection_credential;
					data.esxi_address = res.connection_address;
					data.esxi_port = res.connection_port;
					data.esxi_host = res.host;
					data.esxi_datacenter = res.datacenter;

					// Start restore
					var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Mounting ' + data.volume["volume-id-attributes"].name + ' from Snapshot...', '.window--backupsm .window__main', 'plain');

					return modalInstanceRecovery.opened.then(function () {

						return backupsmFactory.mountRestoreSnapshotDatastore(data);
					}).then(function(res) {
						if (res instanceof Error) throw new Error("Failed to mount datastore snapshot");

						$log.debug("Backups Manager [%s] -> Restore finished successfully", data.uuid);

						modalInstanceRecovery.close();
						return backupsmFactory.setRestoreStatus(data, 2);
					}).catch(function (e) {
						modalInstanceRecovery.close();

						console.log(e);
						return ApplicationsFactory.errorHandler(e.message);
					});

				}, function (rejectionResponse) {
					console.log(2, rejectionResponse);
				});

			});

			/*
			 * Restore files from Storage Snapshot
			 */
			$scope.$on('backupsm__restore_datastore_files', function (event, data) {
				console.log(data);

				data.type = "restore_datastore_files";
				data.restore_name = "Datastore restore (" + data.volume["volume-id-attributes"].name + ")";
				data.uuid = uuid.v4();

				data.volume_junction = data.volume["volume-id-attributes"]["junction-path"];
				data.netapp_credential = data.storage.credential;
				data.netapp_host = data.storage.host;
				data.netapp_port = data.storage.port;
				data.netapp_nfs_ip = $filter('filter')(data.storage.netifaces, {
					vserver: data.vserver["vserver-name"],
					"current-node": data.volume["volume-id-attributes"].node
				});
				data.esxi_datastore_name = 'SysOS_' + data.volume_junction.substr(1);

				$log.debug("Backups Manager [%s] -> Received event [%s] -> Initializing restore of datastore files [%s] from -> storage [%s], vserver [%s], snapshot [%s]", data.uuid, event.name, data.volume["volume-id-attributes"].name, data.netapp_host, data.vserver["vserver-name"], data.snapshot);

				backupsmFactory.setRestore(data);
				backupsmFactory.setActiveRestore(data.uuid);

				var modalInstance = modalFactory.openRegistredModal("ESXiSelectable", ".window--backupsm .window__main",
                    {
                        title: function () {
                            return "Select ESXi host";
                        },
                        ESXihosts: function () {
                            return data.ESXihosts;
                        }
                    }
                );
				modalInstance.result.then(function (res) {

					$log.debug("Backups Manager [%s] -> Received restore data from Modal -> esxi_host", data.uuid, res.host);

					data.esxi_credential = res.connection_credential;
					data.esxi_address = res.connection_address;
					data.esxi_port = res.connection_port;
					data.esxi_host = res.host;
					data.esxi_datacenter = res.datacenter;

					// Start restore
					var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Restoring ' + data.volume["volume-id-attributes"].name + ' files from Snapshot...', '.window--backupsm .window__main', 'plain');

					return modalInstanceRecovery.opened.then(function () {

						return backupsmFactory.restoreSnapshotDatastoreFiles(data);
					}).then(function(res) {
						if (res instanceof Error) throw new Error("Failed to restore snapshot into datastore files");

						$log.debug("Backups Manager [%s] -> Restore finished successfully", data.uuid);

						// Open Datastore Brower application
						ApplicationsFactory.openApplication('datastoreexplorer');
						ApplicationsFactory.toggleApplication('datastoreexplorer');

						$timeout(function () {
							$rootScope.$broadcast("datastoreexplorer__restore_datastore_files", {
								credential: data.esxi_credential,
								host: data.esxi_address,
								port: data.esxi_port,
								id: data.esxi_datastore,
								name: data.esxi_datastore_name,
								original_datastore: data.volume["volume-id-attributes"].name
							});
						}, 100);

						modalInstanceRecovery.close();
						return backupsmFactory.setRestoreStatus(data, 2);
					}).catch(function (e) {
						modalInstanceRecovery.close();

						console.log(e);
						return ApplicationsFactory.errorHandler(e.message);
					});

				}, function (rejectionResponse) {
					console.log(2, rejectionResponse);
				});

			});

			/*
			 * Restore VM guest files from Storage Snapshot
			 */
			$scope.$on('backupsm__restore_vm_guest_files', function (event, data) {
				console.log(data);

				//TODO: folder.folder & resource_pool.resource_pool are required to publish the VM

				data.type = "restore_vm_guest_files";
				data.restore_name = "VM guest files (" + data.vm.name + ")";
				data.uuid = uuid.v4();

				data.volume_junction = data.volume["volume-id-attributes"]["junction-path"];
				data.netapp_credential = data.storage.credential;
				data.netapp_host = data.storage.host;
				data.netapp_port = data.storage.port;
				data.netapp_nfs_ip = $filter('filter')(data.storage.netifaces, {
					vserver: data.vserver["vserver-name"],
					"current-node": data.volume["volume-id-attributes"].node
				});
				data.esxi_datastore_name = 'SysOS_' + data.volume_junction.substr(1);

				$log.debug("Backups Manager [%s] -> Received event [%s] -> Initializing restore of VM guest files [%s] from -> storage [%s], vserver [%s], datastore [%s], snapshot [%s]", data.uuid, event.name, data.vm.name, data.storage.host, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name, data.snapshot);

				backupsmFactory.setRestore(data);
				backupsmFactory.setActiveRestore(data.uuid);

				var modalInstance = modalFactory.openRegistredModal("ESXiSelectable", ".window--backupsm .window__main",
                    {
                        title: function () {
                            return "Select ESXi host";
                        },
                        ESXihosts: function () {
                            return data.ESXihosts;
                        }
                    }
                );
				modalInstance.result.then(function (res) {

					$log.debug("Backups Manager [%s] -> Received restore data from Modal -> esxi_host", data.uuid, res.host);

					data.esxi_credential = res.connection_credential;
					data.esxi_address = res.connection_address;
					data.esxi_port = res.connection_port;
					data.esxi_host = res.host;

					// Start restore
					var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Restoring ' + data.vm.name + ' guest files from Snapshot...', '.window--backupsm .window__main', 'plain');

					return modalInstanceRecovery.opened.then(function () {

						return backupsmFactory.restoreSnapshotVMGuestFiles(data);
					}).then(function(res) {
						if (res instanceof Error) throw new Error("Failed to restore snapshot into VM guest files");

						$log.debug("Backups Manager [%s] -> Restore finished successfully", data.uuid);

						//TODO: mount disk to local and explore it

						modalInstanceRecovery.close();
						return backupsmFactory.setRestoreStatus(data, 2);
					}).catch(function (e) {
						modalInstanceRecovery.close();

						console.log(e);
						return ApplicationsFactory.errorHandler(e.message);
					});

				}, function (rejectionResponse) {
					console.log(2, rejectionResponse);
				});

			});

			/*
			 * VM Instant Recovery from Storage Snapshot
			 */
			$scope.$on('backupsm__vm_instant_recovery', function (event, data) {
				console.log(data);

				data.type = "vm_instant_recovery";
				data.restore_name = "VM instant recovery (" + data.vm.name + ")";
				data.uuid = uuid.v4();

				data.volume_junction = data.volume["volume-id-attributes"]["junction-path"];
				data.netapp_credential = data.storage.credential;
				data.netapp_host = data.storage.host;
				data.netapp_port = data.storage.port;
				data.netapp_nfs_ip = $filter('filter')(data.storage.netifaces, {
					vserver: data.vserver["vserver-name"],
					"current-node": data.volume["volume-id-attributes"].node
				});
				data.esxi_datastore_name = 'SysOS_' + data.volume_junction.substr(1);

				console.log(data);

				$log.debug("Backups Manager [%s] -> Received event [%s] -> Initializing restore of VM [%s] from -> storage [%s], vserver [%s], datastore [%s], snapshot [%s]", data.uuid, event.name, data.vm.name, data.storage.host, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name, data.snapshot);

				backupsmFactory.setRestore(data);
				backupsmFactory.setActiveRestore(data.uuid);

				// User must select ESXi host and its data
				var modalInstanceRestoreVM = modalFactory.openRegistredModal("recoveryWizard", ".window--backupsm .window__main",
                    {
                        title: function () {
                            return "Select required data for Instant VM (" + data.vm.name + ")";
                        },
                        data: function () {
                            return data;
                        }
                    }
                );
				modalInstanceRestoreVM.result.then(function (res) {

					if (res.restore_location === "original") {
						data.esxi_credential = data.current_location.credential;
						data.esxi_address = data.current_location.host;
						data.esxi_port = data.current_location.port;

						$log.debug("Backups Manager [%s] -> Received restore data from Modal as Original location", data.uuid);
					} else if (res.restore_location === "new") {
						data.esxi_credential = res.host.connection_credential;
						data.esxi_address = res.host.connection_address;
						data.esxi_port = res.host.connection_port;
						data.esxi_host = res.host.host;
						data.folder = res.folder.folder;
						data.resource_pool = res.resource_pool.resource_pool;
						data.vm.name = res.vm_name;
						data.vm_power_on = res.vm_power_on;

						$log.debug("Backups Manager [%s] -> Received restore data from Modal as new location-> esxi_host [%s], folder [%s], resource_pool [%s], vm_name [%s], vm_power_on [%s]", data.uuid, res.host.host, res.folder.folder, res.resource_pool.resource_pool, res.vm_name, res.vm_power_on);
					}

					// Start restore
					var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Restoring ' + data.vm.name + ' from Snapshot...', '.window--backupsm .window__main', 'plain');

					return modalInstanceRecovery.opened.then(function () {

						return backupsmFactory.restoreSnapshotIntoInstantVM(data);
					}).then(function(res) {
						if (res instanceof Error) throw new Error("Failed to restore snapshot into Instant VM");

						$log.debug("Backups Manager [%s] -> Restore finished successfully -> instant_vm [%s]", data.uuid, data.vm.vm);

						modalInstanceRecovery.close();
						return backupsmFactory.setRestoreStatus(data, 2);
					}).catch(function (e) {
						modalInstanceRecovery.close();

						console.log(e);
						return ApplicationsFactory.errorHandler(e.message);
					});

				}, function (rejectionResponse) {
					console.log(2, rejectionResponse);
				});

			});

			/*
			 * Restore VM files
			 */
			$scope.$on('backupsm__restore_vm_files', function (event, data) {
				console.log(data);

				//TODO:

			});

			/*
			 * VM Restore from Storage Snapshot
			 */
			$scope.$on('backupsm__restore_vm', function (event, data) {
				console.log(data);

				data.type = "restore_vm";
				data.restore_name = "VM restore (" + data.vm.name + ")";
				data.uuid = uuid.v4();

				data.volume_junction = data.volume["volume-id-attributes"]["junction-path"];
				data.netapp_credential = data.storage.credential;
				data.netapp_host = data.storage.host;
				data.netapp_port = data.storage.port;
				data.netapp_nfs_ip = $filter('filter')(data.storage.netifaces, {
					vserver: data.vserver["vserver-name"],
					"current-node": data.volume["volume-id-attributes"].node
				});
				data.esxi_datastore_name = 'SysOS_' + data.volume_junction.substr(1);

				$log.debug("Backups Manager [%s] -> Received event [%s] -> Initializing restore of VM [%s] from -> storage [%s], vserver [%s], datastore [%s], snapshot [%s]", data.uuid, event.name, data.vm.name, data.storage.host, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name, data.snapshot);

				backupsmFactory.setRestore(data);
				backupsmFactory.setActiveRestore(data.uuid);

				// User must select ESXi host and its data
				var modalInstanceRestoreVM = modalFactory.openRegistredModal("recoveryWizard", ".window--backupsm .window__main",
                    {
                        title: function () {
                            return "Select required data for Restore VM (" + data.vm.name + ")";
                        },
                        data: function () {
                            return data;
                        }
                    }
                );
				modalInstanceRestoreVM.result.then(function (res) {

					if (res.restore_location === "original") {
						data.esxi_credential = data.current_location.credential;
						data.esxi_address = data.current_location.host;
						data.esxi_port = data.current_location.port;

						$log.debug("Backups Manager [%s] -> Received restore data from Modal as Original location", data.uuid);
					} else if (res.restore_location === "new") {
						data.esxi_credential = res.host.connection_credential;
						data.esxi_address = res.host.connection_address;
						data.esxi_port = res.host.connection_port;
						data.esxi_host = res.host.host;
						data.folder = res.folder.folder;
						data.resource_pool = res.resource_pool.resource_pool;
						data.vm.name = res.vm_name;
						data.vm_power_on = res.vm_power_on;

						$log.debug("Backups Manager [%s] -> Received restore data from Modal as new location-> esxi_host [%s], folder [%s], resource_pool [%s], vm_name [%s], vm_power_on [%s]", data.uuid, res.host.host, res.folder.folder, res.resource_pool.resource_pool, res.vm_name, res.vm_power_on);
					}

					// Start restore
					var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Restoring ' + data.vm.name + ' from Snapshot...', '.window--backupsm .window__main', 'plain');

					return modalInstanceRecovery.opened.then(function () {

						return backupsmFactory.restoreSnapshotIntoVM(data);
					}).then(function(res) {
						if (res instanceof Error) throw new Error("Failed to restore snapshot into VM");

						$log.debug("Backups Manager [%s] -> Restore finished successfully -> vm [%s]", data.uuid, data.vm.vm);

						modalInstanceRecovery.close();
						return backupsmFactory.setRestoreStatus(data, 2);
					}).catch(function (e) {
						modalInstanceRecovery.close();

						console.log(e);
						return ApplicationsFactory.errorHandler(e.message);
					});

				}, function (rejectionResponse) {
					console.log(2, rejectionResponse);
				});

			});

			/*
			 * VM backup
			 */
			$scope.$on('backupsm__backup_vm', function (event, data) {
				console.log(data);
				var task_id;
				var stanpshot;

				data.type = "backup_vm";
				data.restore_name = "VM backup (" + data.vm.name + ")";
				data.uuid = uuid.v4();

				data.esxi_credential = data.connection.credential;
				data.esxi_address = data.connection.host;
				data.esxi_port = data.connection.port;
				data.netapp_credential = data.storage.credential;
				data.netapp_host = data.storage.host;
				data.netapp_port = data.storage.port;

				//TODO:
				return vmwareFactory.connectvCenterSoap(data.esxi_credential, data.esxi_address, data.esxi_port).then(function (res) {
					if (res.status === "error") throw new Error("Failed to connect to vCenter");

					return vmwareFactory.getVMState(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm, true);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get VM data");

					console.log("getVMState", res);
					return vmwareFactory.getDatastores(data.esxi_credential, data.esxi_address, data.esxi_port, 'group-d1');
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get datastores");

					console.log("getDatastores", res);
					return vmwareFactory.getDatastoresWithVMsData(data.esxi_credential, data.esxi_address, data.esxi_port, 'group-d1');
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get datastores with VM data");

					console.log("getDatastoresWithVMsData", res);
					return vmwareFactory.getDatastoreProps(data.esxi_credential, data.esxi_address, data.esxi_port, 'datastore-321');
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get datastore");

					console.log("getDatastoreProps", res);
					return vmwareFactory.getFilesDataFromDatastore(data.esxi_credential, data.esxi_address, data.esxi_port, 'datastore-321', 'NFS_MAD', 'tt');
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get files from datastores");

					console.log("getFilesDataFromDatastore", res);
					return vmwareFactory.queryVMEvents(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to query VM events");

					console.log("queryVMEvents", res);
					return vmwareFactory.searchIndexVM(data.esxi_credential, data.esxi_address, data.esxi_port, '502197e9-abe7-06e7-7d88-667c0a8b01ea');
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to searchIndex");

					console.log("searchIndex", res);
					return vmwareFactory.createTask(data.esxi_credential, data.esxi_address, data.esxi_port, 'com.sysos.management.backup', 'VirtualMachine', data.vm.vm);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to create task");

					console.log("createTask", res);

					task_id = res.data.key;

					return vmwareFactory.setTaskState(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 'running');
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to set task state");

					console.log("setTaskState", res);
					return vmwareFactory.updateTaskProgress(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 20);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to update task progress");

					console.log("updateTaskProgress", res);
					return vmwareFactory.searchIndexVM(data.esxi_credential, data.esxi_address, data.esxi_port, '502197e9-abe7-06e7-7d88-667c0a8b01ea');
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to searchIndex");

					console.log("searchIndex", res);
					return vmwareFactory.getVMs(data.esxi_credential, data.esxi_address, data.esxi_port, 'group-d1');
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get VMs");

					console.log("getVMs", res);
					return vmwareFactory.createSnapShot(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm, 'SysOS_backup_' + data.uuid, 'SysOS temporary snapshot. Do not delete this snapshot while a backup is running.', false, true);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to create snapshot");

					console.log("createSnapShot", res);

					stanpshot = res.data[0].propSet.info.result.name;

					return vmwareFactory.updateTaskProgress(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 40);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to update task progress");

					console.log("updateTaskProgress", res);
					return netappFactory.createSnapshot(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to create Volume Snapshot");

					console.log("createSnapShot", res);
					return vmwareFactory.updateTaskProgress(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 60);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to update task progress");

					console.log("updateTaskProgress", res);
					return vmwareFactory.removeSnapshot(data.esxi_credential, data.esxi_address, data.esxi_port, stanpshot, false);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to delete snapshot");

					console.log("removeSnapshot", res);
					return vmwareFactory.updateTaskProgress(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 80);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to update task progress");

					console.log("updateTaskProgress", res);
					return vmwareFactory.setTaskState(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 'success');
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to set task state");

					console.log("setTaskState", res);
				}).catch(function (e) {
					console.log(e);

					// Remove snapshot if exists on error and finish task
					if (stanpshot) {
						return vmwareFactory.removeSnapshot(data.esxi_credential, data.esxi_address, data.esxi_port, stanpshot, false).then(function () {
							return vmwareFactory.setTaskState(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 'error');
						}).catch(function (e) {
							return vmwareFactory.setTaskState(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 'error');
						});
					}

					// Finish task on error
					if (task_id) return vmwareFactory.setTaskState(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 'error');

				});
			});
			/*
			 * ng-click functions
			 */
			this.toggleSide = function () {
				_this.viewSide = !_this.viewSide;
			};

			this.openDatastoreBrowser = function () {
				// Open Datastore Brower application
				ApplicationsFactory.openApplication('datastoreexplorer');
				ApplicationsFactory.toggleApplication('datastoreexplorer');

				var data = _this.getActiveRestore();

				$timeout(function () {
					$rootScope.$broadcast("datastoreexplorer__restore_datastore_files", {
						credential: data.esxi_credential,
						host: data.esxi_address,
						port: data.esxi_port,
						id: data.esxi_datastore,
						name: data.esxi_datastore_name,
						original_datastore: data.volume["volume-id-attributes"].name
					});
				}, 100);
			};

			this.unpublishRestoredInstantVM = function () {
				var current_restore = _this.getActiveRestore();

				var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Initializing restore from Snapshot rollback...', '.window--backupsm .window__main', 'plain');

				return modalInstanceRecovery.opened.then(function () {

					return vmwareFactory.connectvCenterSoap(current_restore.esxi_credential, current_restore.esxi_address, current_restore.esxi_port);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to connect to vCenter");

					return backupsmFactory.unpublishVM(current_restore);
				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to unpublish VM from vCenter");

					return backupsmFactory.unmountDatastore(current_restore);
				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to unmount volume");

					return backupsmFactory.destroyVolume(current_restore);
				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to destroy volume");

					modalFactory.changeModalText('Saving results...', '.window--backupsm .window__main');
					return backupsmFactory.setRestoreStatus(current_restore, "end");
				}).then(function () {
					return modalInstanceRecovery.close();

				}).catch(function (e) {
					modalInstanceRecovery.close();

					console.log(e);
					return ApplicationsFactory.errorHandler(e.message);
				});

			};

			this.unpublishRestoredDatastore = function () {
				var current_restore = _this.getActiveRestore();

				var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Initializing restore from Snapshot rollback...', '.window--backupsm .window__main', 'plain');

				return modalInstanceRecovery.opened.then(function () {

					return vmwareFactory.connectvCenterSoap(current_restore.esxi_credential, current_restore.esxi_address, current_restore.esxi_port);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to connect to vCenter");

					return backupsmFactory.unmountDatastore(current_restore);
				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to unmount volume");

					return backupsmFactory.destroyVolume(current_restore);
				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to destroy volume");

					modalFactory.changeModalText('Saving results...', '.window--backupsm .window__main');
					return backupsmFactory.setRestoreStatus(current_restore, "init");
				}).then(function () {
					return modalInstanceRecovery.close();

				}).catch(function (e) {
					modalInstanceRecovery.close();

					console.log(e);
					return ApplicationsFactory.errorHandler(e.message);
				});

			};

			this.setActiveRestore = function (restore) {
				_this.showNewBackupType = false;
				_this.showRestore = true;
				return backupsmFactory.setActiveRestore(restore.uuid)
			};

			this.doDatastoreBackup = function () {
				vmwareFactory.getVMState( 'vm-322', true).then(function (data) {

				});
			};

		}]);
}());
(function () {
	"use strict";
	backupsmApp.factory('backupsmFactory', ['$filter', 'netappFactory', 'vmwareFactory', 'ServerFactory', 'ApplicationsFactory', 'modalFactory', '$q', '$log',
		function ($filter, netappFactory, vmwareFactory, ServerFactory, ApplicationsFactory, modalFactory, $q, $log) {

			var restores = [];
			var activeRestore;

			/*
			 * -------------------
			 * PRIVATE FUNCTIONS
			 * -------------------
			 */

			var getSnapshotName = function (data) {
				return $filter('filter')(data.snapshots, {
					"snapshot-instance-uuid": data.snapshot
				})[0].name;
			};

			var getLastSnapshot = function (rootSnapshotList) {
				if (rootSnapshotList.hasOwnProperty("childSnapshotList")) return getLastSnapshot(rootSnapshotList.childSnapshotList);

				return rootSnapshotList;
			};

			/*
			 * goToSnapshot
			 */
			var goToSnapshot = function (data) {
				var last_snapshot;

				$log.debug("Backups Manager [%s] -> Get all VM snapshots -> vm [%s]", data.uuid, data.vm.vm);
				return vmwareFactory.getVMSnapshots(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get VM Snapshots");

					// No snapshots found
					if (!res.data[0].propSet) {
						$log.debug("Backups Manager [%s] -> No snapshots found -> vm [%s]", data.uuid, data.vm.vm);
						return res;
					}

					last_snapshot = getLastSnapshot(res.data[0].propSet.snapshot.rootSnapshotList);

					if (last_snapshot.name.startsWith("SysOS_backup_")) {
						$log.debug("Backups Manager [%s] -> Reverting VM to snapshot -> snapshot [%s]", data.uuid, last_snapshot.snapshot.name);
						return vmwareFactory.revertToSnapshot(data.esxi_credential, data.esxi_address, data.esxi_port, last_snapshot.snapshot.name);
					}

					$log.debug("Backups Manager [%s] -> Last snapshot is not from SysOS backup -> snapshot [%s]", data.uuid, last_snapshot.snapshot.name);
					return res;

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get VM Snapshots");

					// No snapshots found
					if (!last_snapshot) return res;

					if (last_snapshot.name.startsWith("SysOS_backup_")) {
						$log.debug("Backups Manager [%s] -> Deleting VM snapshot -> snapshot [%s]", data.uuid, last_snapshot.snapshot.name);
						return vmwareFactory.removeSnapshot(data.esxi_credential, data.esxi_address, data.esxi_port, last_snapshot.snapshot.name, true);
					}

					return res;

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to delete VM Snapshot");

					return res;

				}).catch(function (e) {
					console.log(e);
					return e;
				});
			};

			/*
			 * Clones Storage Volume from Snapshot
			 */
			var cloneVolumeFromSnapshot = function (data) {

				// Create Volume Clone
				$log.debug("Backups Manager [%s] -> Cloning volume from snapshot -> vserver [%s], volume [%s], snapshot [%s]", data.uuid, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name, getSnapshotName(data));
				return netappFactory.cloneVolumeFromSnapshot(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name, getSnapshotName(data)).then(function (res) {
					if (res.status === "error") throw new Error("Failed to clone Volume");

					return setRestoreStatus(data, "cloned");
				}).then(function () {

					// Mount Volume Point
					$log.debug("Backups Manager [%s] -> Mounting cloned volume -> vserver [%s], volume [%s]", data.uuid, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name);
					return netappFactory.mountVolume(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to mount Volume");

					// TODO: check Storage EXPORTS
					// TODO: Create export
					return setRestoreStatus(data, "mounted");

				}).catch(function (e) {
					console.log(e);
					return e;
				});
			};

			/*
			 * Mount storage Datastore to ESXi host
			 */
			var mountVolumeToESXi = function (data) {

				$log.debug("Backups Manager [%s] -> Connection to vCenter using SOAP -> vCenter [%s]", data.uuid, data.esxi_address);
				return vmwareFactory.connectvCenterSoap(data.esxi_credential, data.esxi_address, data.esxi_port).then(function (res) {
					if (res.status === "error") throw new Error("Failed to connect to vCenter");

					// TODO: check connectivity from NFS node
					return vmwareFactory.getHostConfigManagerNetworkSystem(data.esxi_credential, data.esxi_address, data.esxi_port, data.esxi_host);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get networkSystem from vCenter");

					data.networkSystem = res.data;

					// Get Datastore System from ESXi host to mount
					$log.debug("Backups Manager [%s] -> Getting datastore system -> host [%s]", data.uuid, data.esxi_host);
					return vmwareFactory.getHostConfigManagerDatastoreSystem(data.esxi_credential, data.esxi_address, data.esxi_port, data.esxi_host);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get datastoreSystem from vCenter");

					data.datastoreSystem = res.data;

					// TODO: check connectivity from NFS node
					return vmwareFactory.getHostNetworkInfoVnic(data.esxi_credential, data.esxi_address, data.esxi_port, data.networkSystem);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get NetworkInfoVnic from vCenter");

					// TODO: check connectivity from NFS node
					return vmwareFactory.getHostNetworkInfoConsoleVnic(data.esxi_credential, data.esxi_address, data.esxi_port, data.networkSystem);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get NetworkInfoConsoleVnic from vCenter");

					$log.debug("Backups Manager [%s] -> Mount volume to ESXi -> datastoreSystem [%s], nfs_ip [%s], volume [%s], path [%s]", data.uuid, data.datastoreSystem, data.netapp_nfs_ip[0].address, '/SysOS_' + data.volume["volume-id-attributes"].name + '_Restore/', 'SysOS_' + data.volume_junction.substr(1));
					return vmwareFactory.mountDatastore(data.esxi_credential, data.esxi_address, data.esxi_port, data.datastoreSystem, data.netapp_nfs_ip[0].address, '/SysOS_' + data.volume["volume-id-attributes"].name + '_Restore/', 'SysOS_' + data.volume_junction.substr(1));

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to mount Datastore to host");

					// Get mounted datastore name
					data.esxi_datastore = res.data;
					return setRestoreStatus(data, "mounted_to_esx");

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get Datastores from vCenter");
					//TODO: do something with this
					return vmwareFactory.getDatastoreProps(data.esxi_credential, data.esxi_address, data.esxi_port, data.esxi_datastore);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get Datastore Properties from vCenter");

				}).catch(function (e) {
					console.log(e);
					return e;
				});
			};

			/*
			 * Register and power on VM
			 */
			var registerVM = function (data) {

				// Get VM in Datastore
				//TODO: this is required?
				return vmwareFactory.getVMFileDataFromDatastore(
					data.esxi_credential,
					data.esxi_address,
					data.esxi_port,
					data.esxi_datastore,
					'SysOS_' + data.volume_junction.substr(1),
					data.vm.path.substring(0, data.vm.path.lastIndexOf("/") + 1).substr(1),
					data.vm.path.split('/').pop()
				).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get files from datastore");

					// Register VM
					//TODO: check if VM with same name exists
					$log.debug("Backups Manager [%s] -> Register VM to ESXi -> host [%s], vmx_file [%s], vm_name [%s], folder [%s], resource_pool [%s]", data.uuid, data.esxi_host, '[SysOS_' + data.volume_junction.substr(1) + '] ' + data.vm.path, data.vm.name, data.folder, data.resource_pool);
					return vmwareFactory.registerVM(
						data.esxi_credential,
						data.esxi_address,
						data.esxi_port,
						data.esxi_host,
						'[SysOS_' + data.volume_junction.substr(1) + '] ' + data.vm.path,
						data.vm.name,
						data.folder,
						data.resource_pool
					);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to register VM to vCenter");

					data.vm.vm = res.data.result.name;
					return setRestoreStatus(data, "vm_registred");
				}).then(function () {

					return goToSnapshot(data);

				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to revert VM to Snapshot");

					if (data.vm_power_on) {
						// Power On VM
						$log.debug("Backups Manager [%s] -> Powering on vm -> host [%s], VM [%s], ", data.uuid, data.esxi_host, data.vm.vm);
						return vmwareFactory.powerOnVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.esxi_host, data.vm.vm);
					}

				}).then(function (res) {
					if (res && res.status === "error") throw new Error("Failed to power on VM on vCenter");

				}).catch(function (e) {
					console.log(e);
					return e;
				});

			};

			/*
			 * Restore a VM from Snapshot to same location (override)
			 */
			var restoreVMfromSnapshotToCurrentLocation = function (data) {
				var sfr_promises = [];
				var vm_path;

				$log.debug("Backups Manager [%s] -> Connection to vCenter using SOAP -> vCenter [%s]", data.uuid, data.esxi_address);
				return vmwareFactory.connectvCenterSoap(data.esxi_credential, data.esxi_address, data.esxi_port).then(function (res) {
					if (res.status === "error") throw new Error("Failed to connect to vCenter");

					$log.debug("Backups Manager [%s] -> Get VM path -> VM [%s]", data.uuid, data.vm.vm);
					return vmwareFactory.getVMPath(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);
				}).then(function (res) {
					if (res && res.status === "error") throw new Error("Failed to get VM path");
					console.log(res);

					var regex = /\[*\]\s(.*)\/.*\.vmx/gi;
					var str = res.data.propSet["config.files.vmPathName"];

					vm_path = regex.exec(str)[1];

					if (!vm_path) throw new Error("SAFETY STOP: VM cannot be on root folder");

					$log.debug("Backups Manager [%s] -> Get VM runtime -> VM [%s]", data.uuid, data.vm.vm);
					return vmwareFactory.getVMRuntime(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);
				}).then(function (res) {
					if (res && res.status === "error") throw new Error("Failed to get VM runtime");

					if (res.data.propSet.runtime.powerState === "poweredOn") {
						$log.debug("Backups Manager [%s] -> Powering off VM -> VM [%s]", data.uuid, data.vm.vm);
						return vmwareFactory.powerOffVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);
					}

					return res;

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to power off VM at vCenter");

					$log.debug("Backups Manager [%s] -> Get snapshot files from storage -> storage [%s], vserver [%s], volume [%s], snapshot [%s], path [%s]", data.uuid, data.netapp_host, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name, getSnapshotName(data), '/' + vm_path);
					return netappFactory.getSnapshotFiles(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name, getSnapshotName(data), '/' + vm_path);
				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get Snapshot files");

					angular.forEach(res.data, function (file) {
						if (file.name.indexOf(".lck") >= 0) return;

						sfr_promises.push(netappFactory.snapshotRestoreFile(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name, getSnapshotName(data), '/vol/' + data.volume["volume-id-attributes"].name + '/' + vm_path + '/' + file.name).then(function (res) {
							$log.debug("Backups Manager [%s] -> Restoring file from storage snapshot -> storage [%s], vserver [%s], volume [%s], snapshot [%s], path [%s]", data.uuid, data.netapp_host, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name, getSnapshotName(data), '/vol/' + data.volume["volume-id-attributes"].name + '/' + vm_path + '/' + file.name);
							if (res.status === "error") throw new Error("Failed to restore file from storage snapshot");
						}));
					});

					return $q.all(sfr_promises);

				}).then(function () {

					$log.debug("Backups Manager [%s] -> Reloading VM -> VM [%s]", data.uuid, data.vm.vm);
					return vmwareFactory.reloadVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to reload VM");

					return goToSnapshot(data);

				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to revert VM to Snapshot");

					if (data.vm_power_on) {
						// Power On VM
						$log.debug("Backups Manager [%s] -> Powering on vm -> host [%s], VM [%s]", data.uuid, data.vm.runtime.host.name, data.vm.vm);
						return vmwareFactory.powerOnVM(data.current_location.credential, data.current_location.host, data.current_location.port, data.vm.runtime.host.name, data.vm.vm);
					}

					return res;

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to power on VM");
					console.log(res);

				}).catch(function (e) {
					console.log(e);
					return e;
				});
			};

			/*
			 * -------------------
			 * PUBLIC FUNCTIONS
			 * -------------------
			 */

			/*
			 *   - Keeps a track of restore point and updates it to backend.
			 */
			var setRestoreStatus = function (data, status) {
				$filter('filter')(restores, {uuid: data.uuid})[0].status = status;

				return ServerFactory.saveConfigToFile(data, 'applications/backupsm/restores.json', false);
			};

			/*
			* mountRestoreSnapshotDatastore
			*/
			var mountRestoreSnapshotDatastore = function (data) {

				// Create Volume Clone
				return cloneVolumeFromSnapshot(data).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to clone volume from snapshot");

					// Mount Volume
					return mountVolumeToESXi(data);

				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to mount cloned volume from snapshot to ESXi host");

				}).catch(function (e) {
					console.log(e);
					return e;
				});

			};

			/*
			 * restoreSnapshotDatastoreFiles
			 */
			var restoreSnapshotDatastoreFiles = function (data) {

				// Create Volume Clone
				return cloneVolumeFromSnapshot(data).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to clone volume from snapshot");

					// Mount Volume
					return mountVolumeToESXi(data);

				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to mount cloned volume from snapshot to ESXi host");

				}).catch(function (e) {
					console.log(e);
					return e;
				});

			};

			/*
			 * restoreSnapshotVMGuestFiles
			 */
			var restoreSnapshotVMGuestFiles = function (data) {

				// Create Volume Clone
				return cloneVolumeFromSnapshot(data).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to clone volume from snapshot");

					// Mount Volume
					return mountVolumeToESXi(data);

				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to mount cloned volume from snapshot to ESXi host");

					// Get VM in Datastore
					return vmwareFactory.getVMFileDataFromDatastore(
						data.esxi_credential,
						data.esxi_address,
						data.esxi_port,
						data.esxi_datastore,
						'SysOS_' + data.volume_junction.substr(1),
						data.vm.path.substring(0, data.vm.path.lastIndexOf("/") + 1).substr(1),
						data.vm.path.split('/').pop()
					);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get files from datastore");

					// Register VM
					//TODO: check if VM with same name exists
					return vmwareFactory.registerVM(
						data.esxi_credential,
						data.esxi_address,
						data.esxi_port,
						data.esxi_host,
						'[SysOS_' + data.volume_junction.substr(1) + '] ' + data.vm.path,
						data.vm.name,
						data.folder,
						data.resource_pool
					);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to register VM to vCenter");
					return res;



				}).catch(function (e) {
					return e;
				});

			};

			/*
			 * restoreSnapshotVMInstantMachine
			 */
			var restoreSnapshotIntoInstantVM = function (data) {

				// Create Volume Clone
				return cloneVolumeFromSnapshot(data).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to clone volume from snapshot");

					// Mount Volume
					return mountVolumeToESXi(data);

				}).then(function (res) {
					if (res instanceof Error) throw new Error("Failed to mount cloned volume from snapshot to ESXi host");

					return registerVM(data);
				}).then(function(res) {
					if (res instanceof Error) throw new Error("Failed to register VM from snapshot to ESXi host");

					return res;

				}).catch(function (e) {
					console.log(e);
					return e;
				});

			};

			/*
			 * restoreSnapshotIntoVM
			 */
			var restoreSnapshotIntoVM = function (data) {

				//TODO: if new locatipn
				/*return cloneVMFromSnapshot(data).then(function (data) {

				});*/

				// Restore to current location (override VM)
				return restoreVMfromSnapshotToCurrentLocation(data).then(function (data) {

				}).catch(function (e) {
					console.log(e);
					return e;
				});
			};

			/*
			 * Unpublish VM
			 */
			var unpublishVM = function (data) {

				modalFactory.changeModalText('Connecting to vCenter...', '.window--backupsm .window__main');
				return vmwareFactory.connectvCenterSoap(data.esxi_credential, data.esxi_address, data.esxi_port).then(function (res) {
					if (res.status === "error") throw new Error("Failed to connect to vCenter");

					// Check if VM is powered on
					return vmwareFactory.getVMState(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm)

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to get VM state from vCenter");

					// VM not found
					if (res && res.data.hasOwnProperty("ManagedObjectNotFoundFault")) return res;

					// Power Off VM
					if (res.data["runtime.powerState"] === "poweredOn") {
						modalFactory.changeModalText('PLEASE WAIT', 'Powering off VM ...', '.window--backupsm .window__main');
						return vmwareFactory.powerOffVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);
					}

					// VM is Powered Off
					return res;

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to power off VM at vCenter");

					// VM not found
					if (res && res.data.hasOwnProperty("ManagedObjectNotFoundFault")) return res;

					// Unregister VM
					modalFactory.changeModalText('Unregistering VM ...', '.window--backupsm .window__main');
					return vmwareFactory.unregisterVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);

				}).then(function (res) {
					if (res.status === "error") throw new Error("Failed to unregister VM from vCenter");

					return setRestoreStatus(data, "unregistred_vm");
				}).catch(function (e) {
					console.log(e);
					return e;
				});

			};

			/*
			 * Unmount Datastore
			 */
			var unmountDatastore = function (data) {

				// Unregister Datastore
				modalFactory.changeModalText('Unmounting datastore...', '.window--backupsm .window__main');
				return vmwareFactory.unmountDatastore(data.esxi_credential, data.esxi_address, data.esxi_port, data.datastoreSystem, data.esxi_datastore).then(function (res) {
					if (res.status === "error") throw new Error("Failed to unmount datastore from vCenter");

					return setRestoreStatus(data, "unmounted_datastore");
				}).catch(function (e) {
					console.log(e);
					return e;
				});

			};

			/*
			 * Destroy Storage Volume
			 */
			var destroyVolume = function (data) {

				// Unmount NetApp Volume
				modalFactory.changeModalText('Unmounting storage volume...', '.window--backupsm .window__main');
				return netappFactory.unmountVolume(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name).then(function (res) {
					if (res.status === "error" || res.data !== "passed") throw new Error("Failed to unmount volume");

					return setRestoreStatus(data, "netapp_datastore_unmounted");
				}).then(function () {

					// Set NetApp Volume Offline
					modalFactory.changeModalText('Setting volume offline...', '.window--backupsm .window__main');
					return netappFactory.setVolumeOffline(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name);

				}).then(function (res) {
					if (res.status === "error" || res.data !== "passed") throw new Error("Failed to set volume offline");

					return setRestoreStatus(data, "netapp_datastore_offline");
				}).then(function () {

					// Destroy NetApp Volume
					modalFactory.changeModalText('Destroying volume...', '.window--backupsm .window__main');
					return netappFactory.destroyVolume(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver["vserver-name"], data.volume["volume-id-attributes"].name);

				}).then(function (res) {
					if (res.status === "error" || res.data !== "passed") throw new Error("Failed to destroy volume");

					return setRestoreStatus(data, 3);
				}).catch(function (e) {
					console.log(e);
					return e;
				});
			};

			/*
			 * create SnapShot
			 */
			var createSnapShot = function () {

			};

			return {
				setRestores: function (data) {
					restores = data;
				},
				getRestores: function () {
					return restores;
				},
				getActiveRestore: function () {
					return activeRestore;
				},
				setRestore: function (data) {
					data.status = "init";
					return restores.push(data);
				},
				setActiveRestore: function (uuid) {
					return activeRestore = uuid;
				},
				setRestoreStatus: setRestoreStatus,
				mountRestoreSnapshotDatastore: mountRestoreSnapshotDatastore,
				restoreSnapshotVMGuestFiles: restoreSnapshotVMGuestFiles,
				restoreSnapshotDatastoreFiles: restoreSnapshotDatastoreFiles,
				restoreSnapshotIntoInstantVM: restoreSnapshotIntoInstantVM,
				restoreSnapshotIntoVM: restoreSnapshotIntoVM,
				unpublishVM: unpublishVM,
				unmountDatastore: unmountDatastore,
				destroyVolume: destroyVolume,
				createSnapShot: createSnapShot
			}


		}]);
}());
(function () {
  "use strict";
    backupsmApp.run(['$templateCache', function ($templateCache) {

    $templateCache.put('applications/backupsm/modals/ESXiSelectable.html',
      '<div class="modal-header"> \
        <div class="modal-title" id="modal-title">{{esmC.title}}</div> \
      </div> \
      <div class="modal-body" id="modal-body"> \
        <div class="form-group"> \
          <div class="col-sm-12"> \
            <select class="form-control" ng-options="host as host.name for host in esmC.ESXihosts" ng-model="esmC.selectedHost"> \
              <option value="">-- Select a managed ESXi host --</option> \
            </select> \
          </div> \
        </div> \
      </div> \
      <div class="modal-footer"> \
        <button class="btn btn-primary" type="button" ng-click="esmC.selectESXihost()">Select</button> \
      </div>'
    );

  }]);
}());

(function () {
  "use strict";
    backupsmApp.run(['$templateCache', function ($templateCache) {

    $templateCache.put('applications/backupsm/modals/recoveryWizard.html',
      '<div class="modal-header"> \
        <div class="modal-title" id="modal-title">{{wmC.title}}</div> \
      </div> \
      <div class="modal-body modal-recovery-wizard" id="modal-body"> \
        <div class="wizard"> \
          <ul class="nav nav-wizard"> \
            <li ng-class="{\'active\': wmC.step == 1}"> \
              <a ng-click="wmC.step = 1">SnapShot</a> \
            </li> \
            <li ng-class="{\'active\': wmC.step == 2}"> \
              <a ng-click="wmC.step = 2">Recovery mode</a> \
            </li> \
            <li ng-class="{\'active\': wmC.step == 3}"> \
              <a ng-click="wmC.step = 3">Destination</a> \
            </li> \
            <li ng-class="{\'active\': wmC.step == 4}"> \
              <a ng-click="wmC.step = 4">Ready to apply</a> \
            </li> \
          </ul> \
          <form> \
            <div class="tab-content"> \
              <div class="tab-pane" ng-if="wmC.step == 1" ng-class="{\'active\': wmC.step == 1}"> \
                <table class="table table-hover m-t-xl"> \
                  <tbody> \
                    <tr class="cursor-pointer" ng-repeat="snapshot in wmC.data.snapshots"> \
                      <th class="col-sm-1"><input type="radio" name="snapshot" ng-model="wmC.data.snapshot" ng-value="snapshot[\'snapshot-instance-uuid\']"></th> \
                      <th class="col-sm-1">{{::snapshot.name}}</th> \
                    </tr> \
                  </tbody> \
                </table> \
              </div> \
              <div class="tab-pane" ng-if="wmC.step == 2" ng-class="{\'active\': wmC.step == 2}"> \
                <table class="table table-hover m-t-xl"> \
                 <tbody> \
                    <tr class="cursor-pointer"> \
                       <th class="col-sm-1"><input type="radio" name="restore" ng-model="wmC.restoreType" value="original"></th> \
                       <td class="lh-2"><h5>Restore to the original location</h5>Quickly initiate restore of selected VMs to the original location, and with the original name and settings. This option minimizes the chance of user input error.<br/><i class="fa fa-exclamation text-warning"></i> This virtual machine will be powered down during the restore process.</td> \
                    </tr> \
                    <tr class="cursor-pointer"> \
                       <th class="col-sm-1"><input type="radio" name="restore" ng-model="wmC.restoreType" value="new"></th> \
                       <td class="lh-2"><h5>Restore to a new location, or with different settings</h5>Customize restored VM location, and change its settings. The wizard will automatically populate all controls with the original VM settings as the default settings.</td> \
                    </tr> \
                 </tbody> \
              </table> \
              </div> \
              <div class="tab-pane" ng-if="wmC.step == 3" ng-class="{\'active\': wmC.step == 3}"> \
                <div ng-if="wmC.restoreType == \'new\'"> \
                  <div class="form-group"> \
                    <div class="col-sm-12"> \
                      <select class="form-control" ng-options="host as host.name for host in wmC.data.ESXihosts" ng-model="wmC.selectedHost" ng-change="wmC.loadESXidata()"> \
                        <option value="">-- Select a managed ESXi host --</option> \
                      </select> \
                    </div> \
                  </div> \
                  <div class="form-group"> \
                    <div class="col-sm-12"> \
                      <select class="form-control" ng-options="folder as folder.name for folder in wmC.data.folders" ng-model="wmC.selectedFolder"> \
                        <option value="">-- Select a VM folder --</option> \
                      </select> \
                    </div> \
                  </div> \
                  <div class="form-group"> \
                    <div class="col-sm-12"> \
                      <select class="form-control" ng-options="pool as pool.name for pool in wmC.data.resource_pools" ng-model="wmC.selectedPool"> \
                        <option value="">-- Select a Resource Pool --</option> \
                      </select> \
                    </div> \
                  </div> \
                  <div class="form-group"> \
                    <div class="col-sm-12"> \
                      <input class="form-control" type="text" placeholder="Select a VM name" ng-model="wmC.vmName" required> \
                    </div> \
                  </div> \
                  <div class="form-group"> \
                    <div class="col-sm-12"> \
                      Power ON VM \
                      <switch class="pull-right" name="powerON" ng-model="wmC.powerVM" on="on" off="off"></switch> \
                    </div> \
                  </div> \
                </div> \
                <div ng-if="wmC.restoreType == \'original\'"> \
                  <h5>This VM will be restored to same location as original VM.</h5> \
                  <h6><i class="fa fa-exclamation text-warning"></i> Original VM will be powered down during restore.</h6> \
                </div> \
              </div> \
              <div class="tab-pane" ng-if="wmC.step == 4" ng-class="{\'active\': wmC.step == 4}"> \
                <h5> \
                  Instant VM recovery settings: \
                </h5> \
                <ul> \
                  <li>VM: {{wmC.data.vm.name}} from <strong>{{wmC.getSnapshotName()}}</strong></li> \
                  <li>Original Datastore: {{wmC.data.volume[\'volume-id-attributes\'].name}}</li> \
                  <li>Host: {{wmC.selectedHost.name}}</li> \
                  <li>New VM name: {{wmC.vmName}}</li> \
                  <li>Power ON VM: {{wmC.powerVM}}</li> \
                </ul> \
                <p> \
                  After you click Restore, the selected VM will be instantly recovered into your production environment. To finalize the recovery use Storage VMotion to move running VM to the production storage.<br/> \
                  Alternatively, you can perform cold VM migration during your next maintenance window. \
                </p> \
                <p> \
                  If you are performing manual recovery testing, remember to change VM network to non-production before powering on the VM. \
                </p> \
              </div> \
              <div class="clearfix"></div> \
            </div> \
          </form> \
        </div> \
      </div> \
      <div class="modal-footer"> \
        <button class="btn btn-primary" type="button" ng-if="wmC.step == 1" ng-click="wmC.step = 2">Next</button> \
        <button class="btn btn-primary" type="button" ng-if="wmC.step == 2" ng-click="wmC.step = 3">Next</button> \
        <button class="btn btn-primary" type="button" ng-if="wmC.step == 3" ng-click="wmC.step = 4">Next</button> \
        <button class="btn btn-primary" type="button" ng-if="wmC.step == 4" ng-click="wmC.selectData()">Restore</button> \
      </div>'
    );

  }]);
}());

(function () {
	"use strict";
	backupsmApp.run(['$templateCache', function($templateCache) {

		$templateCache.put('templates/applications/actions-backupsm.html',
			'<div class="window__actions" ng-controller="bmActionController as bmA"> \
			  <a class="window__item"  title="New restore" ng-click="bmA.newRestore()"> \
				<i class="fa fa-plus text-success"></i> \
			  </a> \
			  <a class="window__item separator" ></a> \
			</div>'
		);

	}]);
}());
(function () {
	"use strict";
	backupsmApp.run(['$templateCache', function($templateCache) {

		$templateCache.put('templates/applications/body-backupsm.html',
			'<div class="window__body" ng-controller="bmBodyController as bmB"> \
			  <div class="window__side" ng-if="bmB.viewSide"> \
			    <uib-accordion> \
					<div uib-accordion-group class="panel-success" is-open="true"> \
						<uib-accordion-heading> \
							<i class="fa m-t-f" ng-class="{\'fa-chevron-down\': $parent.isOpen, \'fa-chevron-right p-r-\': !$parent.isOpen}"></i> <i class="fa fa-server m-t-f"></i> Backup Jobs \
						</uib-accordion-heading> \
						<uib-accordion close-others="false"> \
							<div class="menu__item" ng-repeat="restore in bmB.restores track by $index" ng-class="{\'active\': restore.uuid == bmB.activeRestore}" ng-click="bmB.setActiveRestore(restore)" ng-if="restore != undefined"> \
								<span class="p-l-xl"> \
									<h5>{{::restore.restore_name}}<br /><small>{{::restore.snapshot}}</small></h5> \
								</span> \
							</div> \
						</uib-accordion> \
					</div> \
				</uib-accordion> \
				<uib-accordion> \
					<div uib-accordion-group class="panel-success" is-open="true"> \
						<uib-accordion-heading> \
							<i class="fa m-t-f" ng-class="{\'fa-chevron-down\': $parent.isOpen, \'fa-chevron-right p-r-\': !$parent.isOpen}"></i> <i class="fa fa-server m-t-f"></i> Restore Jobs \
						</uib-accordion-heading> \
						<uib-accordion close-others="false"> \
							<div class="menu__item" ng-repeat="restore in bmB.restores track by $index" ng-class="{\'active\': restore.uuid == bmB.activeRestore}" ng-click="bmB.setActiveRestore(restore)" ng-if="restore != undefined"> \
								<span class="p-l-xl"> \
									<h5>{{::restore.restore_name}}<br /><small>{{::restore.snapshot}}</small></h5> \
								</span> \
							</div> \
						</uib-accordion> \
					</div> \
				</uib-accordion> \
				<div class="menu__item" ng-repeat="restore in bmB.restores track by $index" ng-class="{\'active\': restore.uuid == bmB.activeRestore}" ng-click="bmB.setActiveRestore(restore)" ng-if="restore != undefined"> \
				  <h5>{{::restore.restore_name}}<br /><small>{{::restore.snapshot}}</small></h5> \
				</div> \
				<div class="secondary-content__new__box__toggle pointer visible-lg"> \
				  <div class="secondary-content__new__box__toggle__slide" ng-click="bmB.toggleSide()"> \
					<i class="fa fa-arrow-left sidebar-open-font open-sidebar"></i> \
				  </div> \
				</div> \
			  </div> \
			  <div class="secondary-content__new__box__toggle toggle_left pointer visible-lg" ng-if="!bmB.viewSide" ng-click="bmB.toggleSide()"> \
				<i class="fa fa-arrow-right sidebar-open-font open-sidebar"></i> \
			  </div> \
			  <div class="window__main"> \
			    <div ng-if="bmB.showNewBackupType == true"> \
					<div ng-include="\'templates/applications/new-backup-type-backupsm.html\'" include-replace></div> \
				</div> \
				<div ng-if="bmB.showRestore == true"> \
					<div ng-include="\'templates/applications/restore-backupsm.html\'"></div> \
				</div> \
			  </div> \
			</div>'
		);

	}]);
}());
(function () {
	"use strict";
	backupsmApp.run(['$templateCache', function($templateCache) {

		$templateCache.put('templates/applications/menu-backupsm.html',
			'<li> \
			  <a > \
				<i class="menu__icon fa fa-search"></i> \
				Search \
			  </a> \
			</li> \
			<li> \
			  <a > \
				<i class="menu__icon fa fa-share-alt"></i> \
				Share \
			  </a> \
			</li> \
			<li> \
			  <a > \
				<i class="menu__icon fa fa-plug"></i> \
				Devices \
			  </a> \
			</li> \
			<li class="divided"> \
			  <a > \
				<i class="menu__icon fa fa-cog"></i> \
				Settings \
			  </a> \
			</li>'
		);

	}]);
}());
(function () {
	"use strict";
	backupsmApp.run(['$templateCache', function($templateCache) {

		$templateCache.put('templates/applications/new-backup-type-backupsm.html',
			'<div class="main_form"> \
			  <p>Select which kind of Backup you want to perform</p> \
			  <table class="table table-hover m-t-xl"> \
				<tbody> \
				  <tr class="cursor-pointer" ng-click="smB.newBackup(\'netapp\')"> \
					<th class="col-sm-2 p-m"><img src="/img/netapp.png" width="75px"></th> \
					<td class="lh-2">Creates a NetApp SnapShot with posterior SnapMirror or SnapVault</td> \
				  </tr> \
				  <tr class="cursor-pointer" ng-click="smB.newConnection(\'mariadb\')"> \
					<th class="col-sm-2 p-m"><img src="/img/mariadb.png" width="75px"></th> \
					<td class="lh-2">Creates a MySQL/MariaDB Database backup</td> \
				  </tr> \
				</tbody> \
			  </table> \
			</div>'
		);

	}]);
}());

(function () {
	"use strict";
	backupsmApp.run(['$templateCache', function($templateCache) {

		$templateCache.put('templates/applications/new-connection-type-backupsm.html',
			'<div class="main_form"> \
			  <p>Select the type of server you want to register with managed infrastructure. All registred servers can be found under the Manager servers node on the Infrastructure tab.</p> \
			  <table class="table table-hover m-t-xl"> \
			  </table> \
			</div>'
		);

	}]);
}());
(function () {
	"use strict";
	backupsmApp.run(['$templateCache', function($templateCache) {

		$templateCache.put('templates/applications/restore-backupsm.html',
			'{{bmB.getActiveRestore().type}} \
			<div ng-if="bmB.getActiveRestore().type == \'mount_restore_datastore\'"> \
				<div ng-if ="bmB.getActiveRestore().status == 2"> \
					<button class="btn btn-primary" type="button" ng-click="bmB.unpublishRestoredDatastore()">Stop Publishing Datastore</button> \
					<button class="btn btn-primary" type="button" ng-click="bmB.openDatastoreBrowser()">Open Datastore Browser</button> \
				</div> \
				Restore status: {{bmB.getActiveRestore().status}} \
			</div> \
			<div ng-if="bmB.getActiveRestore().type == \'restore_datastore_files\'"> \
				<div ng-if ="bmB.getActiveRestore().status == 2"> \
					<button class="btn btn-primary" type="button" ng-click="bmB.unpublishRestoredDatastore()">Stop Publishing Datastore</button> \
					<button class="btn btn-primary" type="button" ng-click="bmB.openDatastoreBrowser()">Open Datastore Browser</button> \
				</div> \
				Restore status: {{bmB.getActiveRestore().status}} \
			</div> \
			<div ng-if="bmB.getActiveRestore().type == \'restore_vm_guest_files\'"> \
				Restore status: {{bmB.getActiveRestore().status}} \
			</div> \
			<div ng-if="bmB.getActiveRestore().type == \'vm_instant_recovery\'"> \
				<div ng-if ="bmB.getActiveRestore().status == 2"> \
					<button class="btn btn-primary" type="button" ng-click="bmB.unpublishRestoredInstantVM()">Stop Publishing Instant VM</button> \
					<button class="btn btn-primary" type="button" ng-click="bmB.migrateInstantVMtoProduction()">Migrate Instant VM to Production</button> \
				</div> \
				Restore status: {{bmB.getActiveRestore().status}} \
			</div>'
		);

	}]);
}());

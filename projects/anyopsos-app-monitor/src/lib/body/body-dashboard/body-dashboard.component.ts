import {AfterViewInit, Component, ElementRef, Input, OnDestroy, ViewChild, ViewEncapsulation} from '@angular/core';
import {Subject} from 'rxjs';
import {takeUntil} from 'rxjs/operators';

// Required to be available inside generateHeadCharts
let NETDATA = null;

import {Application} from '@anyopsos/lib-application';
import {AnyOpsOSLibLoggerService} from '@anyopsos/lib-logger';
import {AnyOpsOSLibExtNetdataService} from '@anyopsos/lib-ext-netdata';

import {AnyOpsOSAppMonitorService} from '../../services/anyopsos-app-monitor.service';

@Component({
  encapsulation: ViewEncapsulation.None,
  selector: 'samon-body-dashboard',
  templateUrl: './body-dashboard.component.html',
  styleUrls: ['./body-dashboard.component.scss']
})
export class BodyDashboardComponent implements AfterViewInit, OnDestroy {
  @ViewChild('chartsDiv', {read: ElementRef}) chartsDiv: ElementRef;
  @Input() application: Application;

  private destroySubject$: Subject<void> = new Subject();

  activeConnection: string;

  connection;

  // ScrollSpy
  currentSection: string = 'menu';

  constructor(private logger: AnyOpsOSLibLoggerService,
              private Monitor: AnyOpsOSAppMonitorService,
              private Netdata: AnyOpsOSLibExtNetdataService) {
    // Get all data generated by the service
    this.Netdata.connections.pipe(takeUntil(this.destroySubject$)).subscribe(connections => {

      // Initialize eventListeners for 1st time
      if (!this.connection && connections[this.activeConnection] && this.chartsDiv) {
        this.chartsDiv.nativeElement.parentNode.addEventListener('resize', connections[this.activeConnection].NETDATA.onresize, connections[this.activeConnection].NETDATA.supportsPassiveEvents() ? {passive: true} : false);
        this.chartsDiv.nativeElement.parentNode.addEventListener('scroll', connections[this.activeConnection].NETDATA.onscroll, connections[this.activeConnection].NETDATA.supportsPassiveEvents() ? {passive: true} : false);
      }

      this.connection = connections[this.activeConnection];
    });
  }

  ngOnDestroy() {
    this.destroySubject$.next();
  }

  ngAfterViewInit() {
    this.Monitor.activeConnection.pipe(takeUntil(this.destroySubject$)).subscribe(activeConnection => {

      // Stop old NETDATA Dashboard
      if (this.activeConnection && this.connection) {
        this.logger.debug('Monitor', 'Stopping old connection on activeConnection change');
        this.Netdata.resetDashboard(this.Monitor.getConnectionByUuid(this.activeConnection));
        this.chartsDiv.nativeElement.parentNode.removeEventListener('resize', this.connection.NETDATA.onresize);
        this.chartsDiv.nativeElement.parentNode.removeEventListener('scroll', this.connection.NETDATA.onscroll);

        // Remove connection reference to delete Template data
        this.connection = undefined;
      }

      this.activeConnection = activeConnection;

      // Initialie NETDATA Dashboard if needed
      if (this.activeConnection && this.Monitor.getConnectionByUuid(this.activeConnection).state !== 'disconnected') {
        this.logger.debug('Monitor', 'Initializing connection on activeConnection change', activeConnection);

        // Set new connection. With setTimeout we make sure old template data is removed
        setTimeout(() => {
          this.connection = this.Netdata.getConnection(this.activeConnection);

          if (this.connection) {
            // Restart NETDATA Dashboard object. With setTimeout we make sure new template data is created
            setTimeout(() => this.connection.NETDATA.parseDom(this.connection.NETDATA.chartRefresher), 100);
            this.chartsDiv.nativeElement.parentNode.addEventListener('resize', this.connection.NETDATA.onresize, this.connection.NETDATA.supportsPassiveEvents() ? {passive: true} : false);
            this.chartsDiv.nativeElement.parentNode.addEventListener('scroll', this.connection.NETDATA.onscroll, this.connection.NETDATA.supportsPassiveEvents() ? {passive: true} : false);
          } else {
            // Create new NETDATA object
            this.Netdata.newDashboard(this.Monitor.getActiveConnection());
            this.Netdata.initializeDynamicDashboard(this.Monitor.getActiveConnection(), this.chartsDiv);
          }
        }, 0);

      }
    });
  }

  headMain() {
    return this.Netdata.headMain(this.activeConnection);
  }

  haveHeads(type, charts) {
    return this.Netdata.haveHeads(this.activeConnection, type, charts);
  }

  generateAllHeadCharts(type, charts, duration) {
    return this.Netdata.generateAllHeadCharts(this.activeConnection, type, charts, duration);
  }

  chartCommonMin(family, context, units) {
    return this.Netdata.chartCommonMin(this.activeConnection, family, context, units);
  }

  chartCommonMax(family, context, units) {
    return this.Netdata.chartCommonMax(this.activeConnection, family, context, units);
  }

  memoryUsage() {
    return this.Netdata.memoryUsage(this.activeConnection);
  }

  trackItemById(index, item) {
    return item ? item.id : undefined;
  }

  // ScrollSpy
  scrollToId(section) {
    document.querySelector('#' + section)
      .scrollIntoView();

    // we must return false to prevent the default action
    return false;
  }

  onSectionChange(sectionId: string) {
    this.currentSection = sectionId;
  }
}

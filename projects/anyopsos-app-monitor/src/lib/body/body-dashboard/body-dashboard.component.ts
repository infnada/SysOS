import {
  AfterViewInit,
  Component,
  ElementRef,
  Input,
  OnDestroy,
  OnInit,
  ViewChild,
  ViewEncapsulation
} from '@angular/core';
import {Subject} from 'rxjs';
import {takeUntil} from 'rxjs/operators';

import {Application} from '@anyopsos/lib-application';
import {AnyOpsOSLibLoggerService} from '@anyopsos/lib-logger';
import {AnyOpsOSLibExtNetdataService} from '@anyopsos/lib-ext-netdata';

import {AnyOpsOSAppMonitorService} from '../../services/anyopsos-app-monitor.service';


// Required to be available inside generateHeadCharts. TODO: STILL required?
const NETDATA = null;

@Component({
  encapsulation: ViewEncapsulation.None,
  selector: 'samon-body-dashboard',
  templateUrl: './body-dashboard.component.html',
  styleUrls: ['./body-dashboard.component.scss']
})
export class BodyDashboardComponent implements AfterViewInit, OnDestroy, OnInit {
  @ViewChild('chartsDiv', {static: false, read: ElementRef}) chartsDiv: ElementRef;
  @Input() application: Application;

  private destroySubject$: Subject<void> = new Subject();

  activeConnection: string;

  connection;

  // ScrollSpy
  currentSection: string = 'menu';

  constructor(private logger: AnyOpsOSLibLoggerService,
              private Monitor: AnyOpsOSAppMonitorService,
              private Netdata: AnyOpsOSLibExtNetdataService) {

  }

  ngOnInit(): void {

    // Get all data generated by the service
    this.Netdata.connections
      .pipe(takeUntil(this.destroySubject$)).subscribe(connections => this.onConnectionsChange(connections));
  }

  ngAfterViewInit() {

    // Listen for activeConnection change. TODO: WHY AfterViewInit??
    this.Monitor.activeConnection
      .pipe(takeUntil(this.destroySubject$)).subscribe((activeConnectionUuid: string) => this.onActiveConnectionChange(activeConnectionUuid));
  }

  ngOnDestroy(): void {

    // Remove all listeners
    this.destroySubject$.next();
  }

  private onConnectionsChange(connections): void {
    // Initialize eventListeners for 1st time
    if (!this.connection && connections[this.activeConnection] && this.chartsDiv) {
      this.chartsDiv.nativeElement.parentNode.addEventListener('resize', connections[this.activeConnection].NETDATA.onresize, connections[this.activeConnection].NETDATA.supportsPassiveEvents() ? {passive: true} : false);
      this.chartsDiv.nativeElement.parentNode.addEventListener('scroll', connections[this.activeConnection].NETDATA.onscroll, connections[this.activeConnection].NETDATA.supportsPassiveEvents() ? {passive: true} : false);
    }

    this.connection = connections[this.activeConnection];
  }

  private onActiveConnectionChange(activeConnectionUuid: string): void {

    // Stop old NETDATA Dashboard
    if (this.activeConnection && this.connection) {
      this.logger.debug('Monitor', 'Stopping old connection on activeConnection change');
      this.Netdata.resetDashboard(this.Monitor.getConnectionByUuid(this.activeConnection));
      this.chartsDiv.nativeElement.parentNode.removeEventListener('resize', this.connection.NETDATA.onresize);
      this.chartsDiv.nativeElement.parentNode.removeEventListener('scroll', this.connection.NETDATA.onscroll);

      // Remove connection reference to delete Template data
      this.connection = undefined;
    }

    this.activeConnection = activeConnectionUuid;

    // Initialie NETDATA Dashboard if needed
    if (this.activeConnection && this.Monitor.getConnectionByUuid(this.activeConnection).state !== 'disconnected') {
      this.logger.debug('Monitor', 'Initializing connection on activeConnection change', arguments);

      // Set new connection. With setTimeout we make sure old template data is removed
      setTimeout(() => {
        this.connection = this.Netdata.getConnection(this.activeConnection);

        if (this.connection) {
          // Restart NETDATA Dashboard object. With setTimeout we make sure new template data is created
          setTimeout(() => this.connection.NETDATA.parseDom(this.connection.NETDATA.chartRefresher), 100);
          this.chartsDiv.nativeElement.parentNode.addEventListener('resize', this.connection.NETDATA.onresize, this.connection.NETDATA.supportsPassiveEvents() ? {passive: true} : false);
          this.chartsDiv.nativeElement.parentNode.addEventListener('scroll', this.connection.NETDATA.onscroll, this.connection.NETDATA.supportsPassiveEvents() ? {passive: true} : false);
        } else {
          // Create new NETDATA object
          this.Netdata.newDashboard(this.Monitor.getActiveConnection());
          this.Netdata.initializeDynamicDashboard(this.Monitor.getActiveConnection(), this.chartsDiv);
        }
      }, 0);

    }
  }

  headMain() {
    return this.Netdata.headMain(this.activeConnection);
  }

  haveHeads(type, charts) {
    return this.Netdata.haveHeads(this.activeConnection, type, charts);
  }

  generateAllHeadCharts(type, charts, duration) {
    return this.Netdata.generateAllHeadCharts(this.activeConnection, type, charts, duration);
  }

  chartCommonMin(family, context, units) {
    return this.Netdata.chartCommonMin(this.activeConnection, family, context, units);
  }

  chartCommonMax(family, context, units) {
    return this.Netdata.chartCommonMax(this.activeConnection, family, context, units);
  }

  memoryUsage() {
    return this.Netdata.memoryUsage(this.activeConnection);
  }

  trackItemById(index, item) {
    return item ? item.id : undefined;
  }

  // ScrollSpy
  scrollToId(section) {
    document.querySelector('#' + section)
      .scrollIntoView();

    // we must return false to prevent the default action
    return false;
  }

  onSectionChange(sectionId: string) {
    this.currentSection = sectionId;
  }
}

/**
Systems OS - 0.0.1

Copyright (c) 2018 Isart Navarro Farell
License: MIT
*/
var backupsmApp = angular.module('backupsmApp', []);

(function () {
    'use strict';
    backupsmApp.run(['ApplicationsFactory', 'ServerFactory', 'backupsmFactory', 'modalFactory', function (ApplicationsFactory, ServerFactory, backupsmFactory, modalFactory) {

        ApplicationsFactory.registerApplication({
            id: 'backupsm',
            ico: 'hdd-o',
            name: 'Backups Manager',
            menu: true,
            actions: true,
            style: 'width:1070px;height:700px;top:5%;left:20%;'
        });

        // Get backups
        ServerFactory
        .getConfigFile('applications/backupsm/backups.json', function (data) {
            return backupsmFactory.setBackups(data.data);
        }, function () {
            console.log('Error');
        });

        // Get restores
        ServerFactory
        .getConfigFile('applications/backupsm/restores.json', function (data) {
            return backupsmFactory.setRestores(data.data);
        }, function () {
            console.log('Error');
        });

        /*
         * Register modals
         */
        modalFactory.registerModal({
            modalId: 'backupWizard',
            templateUrl: 'applications/backupsm/modals/backupWizard.html',
            size: 'lg',
            controllerAs: 'bwmC',
            controller: ['$scope', 'title', 'backupObject', '$uibModalInstance', '$filter', '$timeout', 'connectionsFactory', 'smanagerFactory', 'ApplicationsFactory', 'cmanagerFactory',
                function ($scope, title, backupObject, $uibModalInstance, $filter, $timeout, connectionsFactory, smanagerFactory, ApplicationsFactory, cmanagerFactory) {
                    var _this = this;
                    this.step = 1;
                    this.title = title;
                    this.selectedCount = 0;
                    this.restorePoints = 14;
                    this.quiesceTools = true;

                    // Set default backup job name
                    if (backupObject) {
                        this.backupName = backupObject.name;
                    }

                    // Get all virtual connections
                    var connections = connectionsFactory.getConnectionByCategory('virtual');

                    /*
                     * Select child nodes if needed
                     */
                    var selectChildren = function (children, val) {

                        //set as selected
                        children.isSelected = val;
                        if (children.items) {
                            //recursve to set all children as selected
                            children.items.forEach(function (el) {
                                selectChildren(el, val);
                            });
                        }
                    };

                    /*
                     * Get all selected nodes
                     */
                    var getSelected = function (node, arr) {
                        //if this node is selected add to array
                        if (node.isSelected) {
                            arr.push(node);
                            return arr;
                        }

                        if (node.items) {
                            //if the node has children call getSelected for each and concat to array
                            node.items.forEach(function (childNode) {
                                arr = arr.concat(getSelected(childNode, []));
                            });
                        }
                        return arr;
                    };

                    /*
                     * Close this modal
                     */
                    this.close = function () {
                        $uibModalInstance.close();
                    };

                    /*
                     * Returned data when this modal is closed
                     */
                    this.selectData = function () {
                        if (!_this.backupName || _this.backupName == null) return _this.step = 1;
                        if (!_this.selectedObjects || _this.selectedObjects == null) return _this.step = 2;
                        if (!_this.selectedPrimaryStorage || _this.selectedPrimaryStorage == null) return _this.step = 3;

                        $uibModalInstance.close({
                            backupName: _this.backupName,
                            selectedObjects: _this.selectedObjects,
                            selectedPrimaryStorage: _this.selectedPrimaryStorage,
                            restorePoints: _this.restorePoints,
                            secondaryTarget: _this.secondaryTarget,
                            selectedSecondaryTarget: _this.selectedSecondaryTarget,
                            quiesceTools: _this.quiesceTools,
                            backupNow: _this.backupNow
                        });
                    };

                    /*
                     * Whats credentials for Pre & Post scripts credentials
                     */
                    $scope.$watch(function () {
                        return cmanagerFactory.credentials();
                    }, function (newValue) {
                        _this.credentials = newValue;
                    });

                    /**
                     * HierarchyList
                     */
                    this.expandNode = function (n, $event) {
                        $event.stopPropagation();
                        n.toggle();
                    };

                    this.itemSelect = function (item) {
                        var rootVal = !item.isSelected;
                        selectChildren(item, rootVal);

                        _this.selectedObjects = getSelected(_this.list[0], []);
                        _this.selectedCount = _this.selectedObjects.length;
                    };

                    this.getParentName = function (uuid) {
                        return connectionsFactory.getConnectionByUuid(uuid).hostname;
                    };

                    var prepareHierarchyList = function (connections) {

                        _this.list = [{
                            id: 0,
                            title: 'Virtual',
                            type: 'virtual',
                            items: []
                        }];

                        // Prepare tree list
                        angular.forEach(connections, function (connection, co) {
                            _this.list[0].items[co] = {
                                id: connection.uuid,
                                title: connection.hostname,
                                type: 'vCenter',
                                items: []
                            };

                            angular.forEach(connection.datastores, function (datastore, dat) {
                                _this.list[0].items[co].items[dat] = {
                                    id: datastore.obj.name,
                                    parent: connection.uuid,
                                    title: datastore.name,
                                    items: [], // Required for one time binding of ng-if to not be equal to "undefined"
                                    type: 'Datastore'
                                };

                            });

                            angular.forEach(connection.datacenters, function (datacenter, da) {
                                _this.list[0].items[co].items[da + connection.datastores.length] = {
                                    id: datacenter.datacenter,
                                    parent: connection.uuid,
                                    title: datacenter.name,
                                    items: [],
                                    type: 'Datacenter'
                                };

                                // Get clusters
                                angular.forEach(datacenter.clusters, function (cluster, cl) {
                                    console.log(cluster);
                                    _this.list[0].items[co].items[da + connection.datastores.length].items[cl] = {
                                        id: cluster.cluster,
                                        parent: connection.uuid,
                                        title: cluster.name,
                                        items: [],
                                        type: 'Cluster'
                                    };

                                    var hosts = [];

                                    angular.forEach(cluster.hosts, function (host, ho) {
                                        hosts.push(host.host);
                                        _this.list[0].items[co].items[da + connection.datastores.length].items[cl].items[ho] = {
                                            id: host.host,
                                            object: host,
                                            parent: connection.uuid,
                                            title: host.name,
                                            items: [], // Required for one time binding of ng-if to not be equal to "undefined"
                                            type: 'Host'
                                        };
                                    });

                                    var vmsPerCluster = $filter('filter')(connection.vms, function (vm) {
                                        return hosts.indexOf(vm.runtime.host.name) >= 0;
                                    });

                                    // Get cluster VMs
                                    angular.forEach(vmsPerCluster, function (vm, v) {
                                        _this.list[0].items[co].items[da + connection.datastores.length].items[cl].items[v + cluster.hosts.length] = {
                                            id: vm.vm,
                                            object: vm,
                                            parent: connection.uuid,
                                            title: vm.config.name,
                                            items: [], // Required for one time binding of ng-if to not be equal to "undefined"
                                            type: 'VirtualMachine'
                                        };

                                        if (backupObject && backupObject.vm === vm.vm) {
                                            _this.itemSelect(_this.list[0].items[co].items[da + connection.datastores.length].items[cl].items[v + cluster.hosts.length]);
                                        }

                                    });
                                });

                                // Get standalone hosts
                                angular.forEach(datacenter.hosts, function (host, ho) {
                                    _this.list[0].items[co].items[da + connection.datastores.length].items[ho + datacenter.clusters.length] = {
                                        id: host.host,
                                        object: host,
                                        parent: connection.uuid,
                                        title: host.name,
                                        items: [],
                                        type: 'Host'
                                    };

                                    var vmsPerHost = $filter('filter')(connection.vms, {
                                        runtime: {
                                            host: {
                                                name: host.host
                                            }
                                        }
                                    });

                                    angular.forEach(vmsPerHost, function (vm, v) {
                                        _this.list[0].items[co].items[da + connection.datastores.length].items[ho + datacenter.clusters.length].items[v] = {
                                            id: vm.vm,
                                            object: vm,
                                            parent: connection.uuid,
                                            title: vm.config.name,
                                            items: [], // Required for one time binding of ng-if to not be equal to "undefined"
                                            type: 'VirtualMachine'
                                        };

                                        if (backupObject && backupObject.vm === vm.vm) {
                                            _this.itemSelect(_this.list[0].items[co].items[da + connection.datastores.length].items[ho + datacenter.clusters.length].items[v]);
                                        }
                                    });
                                });
                            });
                        });

                    };

                    prepareHierarchyList(connections);

                    /*
                     * Check if VM is inside a Snapshot supported Storage
                     */
                    this.getLinkByVMwareDatastore = function (item) {
                        var link;
                        var allDatastores = true;

                        // Is a Host
                        if (item.type === 'Host') return false;

                        // Is a Datastore
                        if (item.type === 'Datastore') {
                            link = smanagerFactory.getLinkByVMwareDatastore(item.parent, item.id);
                            if (link) return true;
                            return false;
                        }

                        // Is a VirtualMachine
                        if (item.type === 'VirtualMachine') {

                            if (Array.isArray(item.object.datastore.ManagedObjectReference)) {
                                // Check each datastore in array
                                angular.forEach(item.object.datastore.ManagedObjectReference, function (datastore) {
                                    link = smanagerFactory.getLinkByVMwareDatastore(item.parent, datastore.name);
                                    if (!link) allDatastores = false;
                                });

                                return allDatastores;
                            } else {
                                // All VM files are stored in same Datastore
                                link = smanagerFactory.getLinkByVMwareDatastore(item.parent, item.object.datastore.ManagedObjectReference.name);
                                if (link) return true;
                            }
                            return false;
                        }

                        // All other types
                        return true;

                    };

                    /*
                     * Open CredentialsManager if required
                     */
                    this.manageCredentials = function () {
                        ApplicationsFactory.openApplication('cmanager').then(function () {
                            // Wait for next digest circle before continue in order, preventing $element.click event to "re" toggle to current application
                            $timeout(function () {
                                ApplicationsFactory.toggleApplication('cmanager');
                            }, 0, false);
                        });
                    };

                }]
        });

        modalFactory.registerModal({
            modalId: 'ESXiSelectable',
            templateUrl: 'applications/backupsm/modals/ESXiSelectable.html',
            size: 'sm',
            controllerAs: 'esmC',
            controller: ['title', 'ESXihosts', '$uibModalInstance', function (title, ESXihosts, $uibModalInstance) {
                var _this = this;
                this.title = title;
                this.ESXihosts = ESXihosts;

                this.close = function () {
                    $uibModalInstance.close();
                };

                this.selectESXihost = function () {
                    if (!_this.selectedHost || _this.selectedHost == null) return;
                    $uibModalInstance.close(_this.selectedHost);
                };
            }]
        });

        modalFactory.registerModal({
            modalId: 'recoveryWizard',
            templateUrl: 'applications/backupsm/modals/recoveryWizard.html',
            size: 'lg',
            controllerAs: 'wmC',
            controller: ['title', 'data', '$uibModalInstance', '$timeout', '$log', '$q', '$filter', 'modalFactory', 'ServerFactory', 'vmwareFactory', 'netappFactory', function (title, data, $uibModalInstance, $timeout, $log, $q, $filter, modalFactory, ServerFactory, vmwareFactory, netappFactory) {
                var _this = this;
                var gsp_promises = [];

                this.data = data;
                this.title = title;
                this.step = 1;
                this.hideCurrentLocation = false;
                this.hideNewLocation = false;
                this.restoreType = 'original';
                this.vmName = this.data.vm.name;
                this.powerVM = false;


                // Wait for next digest circle before continue
                $timeout(function () {

                    //On init check if VM exists in storage snapshot "this.data.snapshots"
                    var modalInstanceText = modalFactory.openLittleModal('PLEASE WAIT', 'Searching VM in SnapShots...', '.modal-recovery-wizard', 'plain');

                    var regex = /\[*\]\s(.*)\/.*\.vmx/gi;
                    var str = _this.data.vm.config.files.vmPathName;

                    var vm_path = regex.exec(str)[1];
                    if (!vm_path) throw new Error('SAFETY STOP: VM cannot be on root folder');

                    angular.forEach(data.snapshots, function (snapshot, i) {

                        $log.debug('Backups Manager [%s] -> Check VM from storage snapshot -> storage [%s], vserver [%s], volume [%s], snapshot [%s], path [%s]', _this.data.uuid, _this.data.netapp_host, _this.data.vserver['vserver-name'], _this.data.volume['volume-id-attributes'].name, snapshot.name, '/' + vm_path);
                        gsp_promises.push(netappFactory.getSnapshotFiles(
                            _this.data.netapp_credential,
                            _this.data.netapp_host,
                            _this.data.netapp_port,
                            _this.data.vserver['vserver-name'],
                            _this.data.volume['volume-id-attributes'].name,
                            snapshot.name,
                            '/' + vm_path
                        ).then(function (res) {
                            if (res.status === 'error') {
                                $log.debug('Backups Manager [%s] -> No VM data at this storage snapshot -> storage [%s], vserver [%s], volume [%s], snapshot [%s], path [%s]', _this.data.uuid, _this.data.netapp_host, _this.data.vserver['vserver-name'], _this.data.volume['volume-id-attributes'].name, snapshot.name, '/' + vm_path);
                                _this.data.snapshots[i].disabled = true;
                            }
                        }));
                    });

                    return $q.all(gsp_promises).then(function () {
                        modalInstanceText.close();
                    }).catch(function (e) {
                        console.log(e);
                        modalInstanceText.close();
                    });

                }, 0, false);

                if (this.data.type === 'vm_instant_recovery') {
                    this.hideCurrentLocation = true;
                    this.restoreType = 'new';
                    this.vmName = this.data.vm.name + '-IVM';
                }

                if (this.data.type === 'restore_vm') {
                    this.hideNewLocation = true;
                    this.restoreType = 'original';
                    this.vmName = this.data.vm.name;
                }

                this.close = function () {
                    $uibModalInstance.close();
                };

                this.getSnapshotName = function () {
                    return $filter('filter')(data.snapshots, {
                        'snapshot-instance-uuid': data.snapshot
                    })[0].name;
                };

                this.selectData = function () {
                    if ((!_this.selectedHost || _this.selectedHost == null) && _this.restoreType === 'new') return _this.step = 3;
                    if ((!_this.selectedFolder || _this.selectedFolder == null) && _this.restoreType === 'new') return _this.step = 3;
                    if ((!_this.selectedPool || _this.selectedPool == null) && _this.selectedPool === 'new') return _this.step = 3;

                    $uibModalInstance.close({
                        host: _this.selectedHost,
                        folder: _this.selectedFolder,
                        resource_pool: _this.selectedPool,
                        vm_name: _this.vmName,
                        vm_power_on: _this.powerVM,
                        restore_location: _this.restoreType
                    });
                };

                /*
                 * Load Folders and Resource Pools
                 */
                this.loadESXidata = function () {
                    var modalInstanceText = modalFactory.openLittleModal('PLEASE WAIT', 'Connecting to vCenter...', '.modal-recovery-wizard', 'plain');

                    return ServerFactory.connectVcenter(_this.selectedHost.connection_address, _this.selectedHost.connection_credential, _this.selectedHost.connection_port).then(function (con) {
                        if (con.data.status === 'error') throw new Error(con.data.data);

                        modalFactory.changeModalText('Getting data...', '.modal-recovery-wizard');

                        return vmwareFactory.connectvCenterSoap(_this.selectedHost.connection_credential, _this.selectedHost.connection_address, _this.selectedHost.connection_port);

                    }).then(function (res) {
                        if (res.status === 'error') throw new Error('Failed to connect to vCenter');

                        // Get Host data
                        return vmwareFactory.getHost(_this.selectedHost.connection_credential, _this.selectedHost.connection_address, _this.selectedHost.connection_port, _this.selectedHost.host);
                    }).then(function (res) {
                        if (res.status === 'error') throw new Error('Failed to get Host from vCenter');

                        // Get Resource Pools
                        if (res.data.parent.type === 'ClusterComputeResource') {
                            return vmwareFactory.getClusterComputeResource(_this.selectedHost.connection_credential, _this.selectedHost.connection_address, _this.selectedHost.connection_port, res.data.parent.name);
                        }

                        if (res.data.parent.type === 'ComputeResource') {
                            return vmwareFactory.getComputeResource(_this.selectedHost.connection_credential, _this.selectedHost.connection_address, _this.selectedHost.connection_port, res.data.parent.name);
                        }

                    }).then(function (res) {
                        if (res.status === 'error') throw new Error('Failed to get Host computeResource from vCenter');

                        return vmwareFactory.getResourcePool(_this.selectedHost.connection_credential, _this.selectedHost.connection_address, _this.selectedHost.connection_port, res.data[0].resourcePool.name);
                    }).then(function (res) {
                        if (res.status === 'error') throw new Error('Failed to get Host resourcePool from vCenter');

                        _this.data.resource_pools = [res.data];

                        // Get VM folders in selected vCenter
                        return ServerFactory.callVcenter(_this.selectedHost.connection_address, _this.selectedHost.connection_port, '/rest/vcenter/folder?filter.type=VIRTUAL_MACHINE').then(function (data_folder) {
                            if (data_folder.data.status === 'error') throw new Error(data_folder.data.data);
                            _this.data.folders = data_folder.data.data.response.value;

                            modalInstanceText.close();
                        });
                    });
                };

            }]
        });

    }]);
}());
(function () {
    'use strict';
    backupsmApp.controller('bmActionController', ['$scope', function ($scope) {

        var _this = this;
        var APPscope = $scope.$parent.$parent.$parent.$parent;

        /*
         * ng-click functions
         */
        this.newRestore = function () {
            APPscope.$broadcast('backupsm__new_restore');
        };

    }]);
}());
(function () {
    'use strict';
    backupsmApp.controller('bmBodyController', ['$rootScope', '$scope', '$filter', '$timeout', '$log', 'uuid', 'backupsmFactory', 'modalFactory', 'ApplicationsFactory', 'vmwareFactory', 'netappFactory',
        function ($rootScope, $scope, $filter, $timeout, $log, uuid, backupsmFactory, modalFactory, ApplicationsFactory, vmwareFactory, netappFactory) {

            var _this = this;

            this.viewSide = true;
            this.showNewBackupType = true;
            this.showRestore = false;
            this.restores = [];
            this.active = null;

            /*
             * Bindings
             */
            $scope.$watch(function () {
                return backupsmFactory.getRestores();
            }, function (newValue) {
                _this.restores = newValue;
            });

            $scope.$watch(function () {
                return backupsmFactory.getBackups();
            }, function (newValue) {
                _this.backups = newValue;
            });

            $scope.$watch(function () {
                return backupsmFactory.getActive();
            }, function (newValue) {
                _this.active = newValue;
            });

            /*
             * Called at backupsmActionController
             */
            $scope.$on('backupsm__new_restore', function () {
                _this.showNewBackupType = true;
                _this.showRestore = false;
            });

            /*
             * Returns restore data from active restore
             */
            this.getActive = function () {
                return $filter('filter')(_this.restores, {uuid: _this.active})[0];
            };

            /**
             * ---------------------
             * Outside calls
             * ---------------------
             */

            /**
             * Mount Restore Datastore from Storage Snapshot
             */
            $scope.$on('backupsm__mount_restore_datastore', function (event, data) {
                console.log(data);

                data.type = 'mount_restore_datastore';
                data.restore_name = 'Datastore mount (' + data.volume['volume-id-attributes'].name + ')';
                data.uuid = uuid.v4();

                data.volume_junction = data.volume['volume-id-attributes']['junction-path'];
                data.netapp_credential = data.storage.credential;
                data.netapp_host = data.storage.host;
                data.netapp_port = data.storage.port;
                data.netapp_nfs_ip = $filter('filter')(data.storage.netifaces, {
                    vserver: data.vserver['vserver-name'],
                    'current-node': data.volume['volume-id-attributes'].node
                });
                data.esxi_datastore_name = 'SysOS_' + data.volume_junction.substr(1);
                $log.debug('Backups Manager [%s] -> Received event [%s] -> Initializing mount of datastore [%s] from -> storage [%s], vserver [%s], snapshot [%s]', data.uuid, event.name, data.volume['volume-id-attributes'].name, data.netapp_host, data.vserver['vserver-name'], data.snapshot);

                backupsmFactory.setRestore(data);
                backupsmFactory.setRestoreStatus(data, 'init');
                backupsmFactory.setActive(data.uuid);

                var modalInstance = modalFactory.openRegistredModal('ESXiSelectable', '.window--backupsm .window__main',
                    {
                        title: function () {
                            return 'Select ESXi host';
                        },
                        ESXihosts: function () {
                            return data.ESXihosts;
                        }
                    }
                );
                modalInstance.result.then(function (res) {

                    $log.debug('Backups Manager [%s] -> Received restore data from Modal -> esxi_host', data.uuid, res.host);

                    data.esxi_credential = res.connection_credential;
                    data.esxi_address = res.connection_address;
                    data.esxi_port = res.connection_port;
                    data.esxi_host = res.host;
                    data.esxi_datacenter = res.datacenter;

                    // Start restore
                    var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Mounting ' + data.volume['volume-id-attributes'].name + ' from Snapshot...', '.window--backupsm .window__main', 'plain');

                    return modalInstanceRecovery.opened.then(function () {

                        return backupsmFactory.mountRestoreSnapshotDatastore(data);
                    }).then(function (res) {
                        if (res instanceof Error) throw new Error('Failed to mount datastore snapshot');

                        $log.debug('Backups Manager [%s] -> Restore finished successfully', data.uuid);

                        modalInstanceRecovery.close();
                        return backupsmFactory.setRestoreStatus(data, 'end');
                    }).catch(function (e) {
                        modalInstanceRecovery.close();

                        console.log(e);
                        return ApplicationsFactory.errorHandler(e.message);
                    });

                }, function (rejectionResponse) {
                    console.log(2, rejectionResponse);
                });

            });

            /*
             * Restore files from Storage Snapshot
             */
            $scope.$on('backupsm__restore_datastore_files', function (event, data) {
                console.log(data);

                data.type = 'restore_datastore_files';
                data.restore_name = 'Datastore restore (' + data.volume['volume-id-attributes'].name + ')';
                data.uuid = uuid.v4();

                data.volume_junction = data.volume['volume-id-attributes']['junction-path'];
                data.netapp_credential = data.storage.credential;
                data.netapp_host = data.storage.host;
                data.netapp_port = data.storage.port;
                data.netapp_nfs_ip = $filter('filter')(data.storage.netifaces, {
                    vserver: data.vserver['vserver-name'],
                    'current-node': data.volume['volume-id-attributes'].node
                });
                data.esxi_datastore_name = 'SysOS_' + data.volume_junction.substr(1);
                $log.debug('Backups Manager [%s] -> Received event [%s] -> Initializing restore of datastore files [%s] from -> storage [%s], vserver [%s], snapshot [%s]', data.uuid, event.name, data.volume['volume-id-attributes'].name, data.netapp_host, data.vserver['vserver-name'], data.snapshot);

                backupsmFactory.setRestore(data);
                backupsmFactory.setRestoreStatus(data, 'init');
                backupsmFactory.setActive(data.uuid);

                var modalInstance = modalFactory.openRegistredModal('ESXiSelectable', '.window--backupsm .window__main',
                    {
                        title: function () {
                            return 'Select ESXi host';
                        },
                        ESXihosts: function () {
                            return data.ESXihosts;
                        }
                    }
                );
                modalInstance.result.then(function (res) {

                    $log.debug('Backups Manager [%s] -> Received restore data from Modal -> esxi_host', data.uuid, res.host);

                    data.esxi_credential = res.connection_credential;
                    data.esxi_address = res.connection_address;
                    data.esxi_port = res.connection_port;
                    data.esxi_host = res.host;
                    data.esxi_datacenter = res.datacenter;

                    // Start restore
                    var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Restoring ' + data.volume['volume-id-attributes'].name + ' files from Snapshot...', '.window--backupsm .window__main', 'plain');

                    return modalInstanceRecovery.opened.then(function () {

                        return backupsmFactory.restoreSnapshotDatastoreFiles(data);
                    }).then(function (res) {
                        if (res instanceof Error) throw new Error('Failed to restore snapshot into datastore files');

                        $log.debug('Backups Manager [%s] -> Restore finished successfully', data.uuid);

                        // Open Datastore Brower application
                        ApplicationsFactory.openApplication('datastoreexplorer').then(function () {
                            // Wait for next digest circle before continue in order, preventing $element.click event to "re" toggle to current application
                            $timeout(function () {
                                ApplicationsFactory.toggleApplication('datastoreexplorer');
                            }, 0, false);
                        });

                        $timeout(function () {
                            $rootScope.$broadcast('datastoreexplorer__restore_datastore_files', {
                                credential: data.esxi_credential,
                                host: data.esxi_address,
                                port: data.esxi_port,
                                id: data.esxi_datastore,
                                name: data.esxi_datastore_name,
                                original_datastore: data.volume['volume-id-attributes'].name
                            });
                        }, 100);

                        modalInstanceRecovery.close();
                        return backupsmFactory.setRestoreStatus(data, 'end');
                    }).catch(function (e) {
                        modalInstanceRecovery.close();

                        console.log(e);
                        return ApplicationsFactory.errorHandler(e.message);
                    });

                }, function (rejectionResponse) {
                    console.log(2, rejectionResponse);
                });

            });

            /*
             * Restore VM guest files from Storage Snapshot
             */
            $scope.$on('backupsm__restore_vm_guest_files', function (event, data) {
                console.log(data);

                //TODO: folder.folder & resource_pool.resource_pool are required to publish the VM

                data.type = 'restore_vm_guest_files';
                data.restore_name = 'VM guest files (' + data.vm.name + ')';
                data.uuid = uuid.v4();

                data.volume_junction = data.volume['volume-id-attributes']['junction-path'];
                data.netapp_credential = data.storage.credential;
                data.netapp_host = data.storage.host;
                data.netapp_port = data.storage.port;
                data.netapp_nfs_ip = $filter('filter')(data.storage.netifaces, {
                    vserver: data.vserver['vserver-name'],
                    'current-node': data.volume['volume-id-attributes'].node
                });
                data.esxi_datastore_name = 'SysOS_' + data.volume_junction.substr(1);
                $log.debug('Backups Manager [%s] -> Received event [%s] -> Initializing restore of VM guest files [%s] from -> storage [%s], vserver [%s], datastore [%s], snapshot [%s]', data.uuid, event.name, data.vm.name, data.storage.host, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name, data.snapshot);

                backupsmFactory.setRestore(data);
                backupsmFactory.setRestoreStatus(data, 'init');
                backupsmFactory.setActive(data.uuid);

                var modalInstance = modalFactory.openRegistredModal('ESXiSelectable', '.window--backupsm .window__main',
                    {
                        title: function () {
                            return 'Select ESXi host';
                        },
                        ESXihosts: function () {
                            return data.ESXihosts;
                        }
                    }
                );
                modalInstance.result.then(function (res) {

                    $log.debug('Backups Manager [%s] -> Received restore data from Modal -> esxi_host', data.uuid, res.host);

                    data.esxi_credential = res.connection_credential;
                    data.esxi_address = res.connection_address;
                    data.esxi_port = res.connection_port;
                    data.esxi_host = res.host;

                    // Start restore
                    var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Restoring ' + data.vm.name + ' guest files from Snapshot...', '.window--backupsm .window__main', 'plain');

                    return modalInstanceRecovery.opened.then(function () {

                        return backupsmFactory.restoreSnapshotVMGuestFiles(data);
                    }).then(function (res) {
                        if (res instanceof Error) throw new Error('Failed to restore snapshot into VM guest files');

                        $log.debug('Backups Manager [%s] -> Restore finished successfully', data.uuid);

                        //TODO: mount disk to local and explore it

                        modalInstanceRecovery.close();
                        return backupsmFactory.setRestoreStatus(data, 'end');
                    }).catch(function (e) {
                        modalInstanceRecovery.close();

                        console.log(e);
                        return ApplicationsFactory.errorHandler(e.message);
                    });

                }, function (rejectionResponse) {
                    console.log(2, rejectionResponse);
                });

            });

            /*
             * VM Instant Recovery from Storage Snapshot
             */
            $scope.$on('backupsm__vm_instant_recovery', function (event, data) {
                console.log(data);

                data.type = 'vm_instant_recovery';
                data.restore_name = 'VM instant recovery (' + data.vm.name + ')';
                data.uuid = uuid.v4();

                data.volume_junction = data.volume['volume-id-attributes']['junction-path'];
                data.netapp_credential = data.storage.credential;
                data.netapp_host = data.storage.host;
                data.netapp_port = data.storage.port;
                data.netapp_nfs_ip = $filter('filter')(data.storage.netifaces, {
                    vserver: data.vserver['vserver-name'],
                    'current-node': data.volume['volume-id-attributes'].node
                });
                data.esxi_datastore_name = 'SysOS_' + data.volume_junction.substr(1);

                console.log(data);

                $log.debug('Backups Manager [%s] -> Received event [%s] -> Initializing restore of VM [%s] from -> storage [%s], vserver [%s], datastore [%s], snapshot [%s]', data.uuid, event.name, data.vm.name, data.storage.host, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name, data.snapshot);

                backupsmFactory.setRestore(data);
                backupsmFactory.setRestoreStatus(data, 'init');
                backupsmFactory.setActive(data.uuid);

                // User must select ESXi host and its data
                var modalInstanceRestoreVM = modalFactory.openRegistredModal('recoveryWizard', '.window--backupsm .window__main',
                    {
                        title: function () {
                            return 'Select required data for Instant VM (' + data.vm.name + ')';
                        },
                        data: function () {
                            return data;
                        }
                    }
                );
                modalInstanceRestoreVM.result.then(function (res) {

                    data.esxi_credential = res.host.connection_credential;
                    data.esxi_address = res.host.connection_address;
                    data.esxi_port = res.host.connection_port;
                    data.esxi_host = res.host.host;
                    data.folder = res.folder.folder;
                    data.resource_pool = res.resource_pool.obj.name;
                    data.vm.name = res.vm_name;
                    data.vm_power_on = res.vm_power_on;

                    $log.debug('Backups Manager [%s] -> Received restore data from Modal as new location -> esxi_host [%s], folder [%s], resource_pool [%s], vm_name [%s], vm_power_on [%s]', data.uuid, res.host.host, res.folder.folder, res.resource_pool.resource_pool, res.vm_name, res.vm_power_on);

                    // Start restore
                    var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Restoring ' + data.vm.name + ' from Snapshot...', '.window--backupsm .window__main', 'plain');

                    return modalInstanceRecovery.opened.then(function () {

                        return backupsmFactory.restoreSnapshotIntoInstantVM(data);
                    }).then(function (res) {
                        if (res instanceof Error) throw new Error('Failed to restore snapshot into Instant VM');

                        $log.debug('Backups Manager [%s] -> Restore finished successfully -> instant_vm [%s]', data.uuid, data.vm.vm);

                        modalInstanceRecovery.close();
                        return backupsmFactory.setRestoreStatus(data, 'end');
                    }).catch(function (e) {
                        modalInstanceRecovery.close();

                        console.log(e);
                        return ApplicationsFactory.errorHandler(e.message);
                    });

                }, function (rejectionResponse) {
                    console.log(2, rejectionResponse);
                });

            });

            /*
             * VM Restore from Storage Snapshot
             */
            $scope.$on('backupsm__restore_vm', function (event, data) {
                console.log(data);

                data.type = 'restore_vm';
                data.restore_name = 'VM restore (' + data.vm.name + ')';
                data.uuid = uuid.v4();

                data.volume_junction = data.volume['volume-id-attributes']['junction-path'];
                data.netapp_credential = data.storage.credential;
                data.netapp_host = data.storage.host;
                data.netapp_port = data.storage.port;
                data.netapp_nfs_ip = $filter('filter')(data.storage.netifaces, {
                    vserver: data.vserver['vserver-name'],
                    'current-node': data.volume['volume-id-attributes'].node
                });
                data.esxi_datastore_name = 'SysOS_' + data.volume_junction.substr(1);
                $log.debug('Backups Manager [%s] -> Received event [%s] -> Initializing restore of VM [%s] from -> storage [%s], vserver [%s], datastore [%s], snapshot [%s]', data.uuid, event.name, data.vm.name, data.storage.host, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name, data.snapshot);

                backupsmFactory.setRestore(data);
                backupsmFactory.setRestoreStatus(data, 'init');
                backupsmFactory.setActive(data.uuid);

                // User must select ESXi host and its data
                var modalInstanceRestoreVM = modalFactory.openRegistredModal('recoveryWizard', '.window--backupsm .window__main',
                    {
                        title: function () {
                            return 'Select required data for Restore VM (' + data.vm.name + ')';
                        },
                        data: function () {
                            return data;
                        }
                    }
                );
                modalInstanceRestoreVM.result.then(function (res) {

                    data.esxi_credential = data.current_location.credential;
                    data.esxi_address = data.current_location.host;
                    data.esxi_port = data.current_location.port;
                    data.vm_power_on = res.vm_power_on;

                    $log.debug('Backups Manager [%s] -> Received restore data from Modal as Original location -> instant_vm [%s]', data.uuid, data.vm_power_on);

                    // Start restore
                    var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Restoring ' + data.vm.name + ' from Snapshot...', '.window--backupsm .window__main', 'plain');

                    return modalInstanceRecovery.opened.then(function () {

                        return backupsmFactory.restoreSnapshotIntoVM(data);
                    }).then(function (res) {
                        if (res instanceof Error) throw new Error('Failed to restore snapshot into VM');

                        $log.debug('Backups Manager [%s] -> Restore finished successfully -> vm [%s]', data.uuid, data.vm.vm);

                        modalInstanceRecovery.close();
                        return backupsmFactory.setRestoreStatus(data, 'end');
                    }).catch(function (e) {
                        modalInstanceRecovery.close();

                        console.log(e);
                        return ApplicationsFactory.errorHandler(e.message);
                    });

                }, function (rejectionResponse) {
                    console.log(2, rejectionResponse);
                });

            });

            /*
             * VM backup
             */
            $scope.$on('backupsm__backup_vm', function (event, data) {
                console.log(data);

                data.type = 'backup_vm';
                data.backup_name = 'VM backup (' + data.vm.name + ')';
                data.uuid = uuid.v4();

                $log.debug('Backups Manager [%s] -> Received event [%s] -> Initializing backup', data.uuid, event.name);

                backupsmFactory.setBackup(data);
                backupsmFactory.setBackupStatus(data, 'init');
                backupsmFactory.setActive(data.uuid);

                var modalInstanceBackup = modalFactory.openRegistredModal('backupWizard', '.window--backupsm .window__main', {
                    title: function () {
                        return 'Backup Wizard';
                    },
                    backupObject: function () {
                        return data.vm;
                    }
                });
                modalInstanceBackup.result.then(function (res) {
                    console.log(res);

                    data.backup_name = 'VM backup (' + res.backupName + ')';
                    res.uuid = data.uuid;

                    $log.debug('Backups Manager [%s] -> Received backup data from Modal -> name [%s]', data.uuid, res.backupName);

                    // Start backup
                    var modalInstanceBackup = modalFactory.openLittleModal('PLEASE WAIT', 'Backing up ' + res.backupName + '...', '.window--backupsm .window__main', 'plain');

                    return modalInstanceBackup.opened.then(function () {

                        return backupsmFactory.startVMBackup(res);
                    }).then(function (res) {
                        if (res instanceof Error) throw new Error('Failed to backup VM');

                        $log.debug('Backups Manager [%s] -> Backup finished successfully', data.uuid);

                        modalInstanceBackup.close();
                        return backupsmFactory.setBackupStatus(data, 'end');
                    }).catch(function (e) {
                        modalInstanceBackup.close();

                        console.log(e);
                        return ApplicationsFactory.errorHandler(e.message);
                    });

                }, function (rejectionResponse) {
                    console.log(2, rejectionResponse);
                });
            });

            /*
             * ng-click functions
             */
            this.toggleSide = function () {
                _this.viewSide = !_this.viewSide;
            };

            this.openDatastoreBrowser = function () {
                // Open Datastore Brower application
                ApplicationsFactory.openApplication('datastoreexplorer').then(function () {
                    // Wait for next digest circle before continue in order, preventing $element.click event to "re" toggle to current application
                    $timeout(function () {
                        ApplicationsFactory.toggleApplication('datastoreexplorer');
                    }, 0, false);
                });

                var data = _this.getActive();

                $timeout(function () {
                    $rootScope.$broadcast('datastoreexplorer__restore_datastore_files', {
                        credential: data.esxi_credential,
                        host: data.esxi_address,
                        port: data.esxi_port,
                        id: data.esxi_datastore,
                        name: data.esxi_datastore_name,
                        original_datastore: data.volume['volume-id-attributes'].name
                    });
                }, 100);
            };

            this.unpublishRestoredInstantVM = function () {
                var current_restore = _this.getActive();

                var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Initializing restore from Snapshot rollback...', '.window--backupsm .window__main', 'plain');

                return modalInstanceRecovery.opened.then(function () {

                    return vmwareFactory.connectvCenterSoap(current_restore.esxi_credential, current_restore.esxi_address, current_restore.esxi_port);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to connect to vCenter');

                    return backupsmFactory.unpublishVM(current_restore);
                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to unpublish VM from vCenter');

                    return backupsmFactory.unmountDatastore(current_restore);
                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to unmount volume');

                    return backupsmFactory.destroyVolume(current_restore);
                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to destroy volume');

                    modalFactory.changeModalText('Saving results...', '.window--backupsm .window__main');
                    return backupsmFactory.setRestoreStatus(current_restore, 'end');
                }).then(function () {
                    return modalInstanceRecovery.close();

                }).catch(function (e) {
                    modalInstanceRecovery.close();

                    console.log(e);
                    return ApplicationsFactory.errorHandler(e.message);
                });

            };

            this.unpublishRestoredDatastore = function () {
                var current_restore = _this.getActive();

                var modalInstanceRecovery = modalFactory.openLittleModal('PLEASE WAIT', 'Initializing restore from Snapshot rollback...', '.window--backupsm .window__main', 'plain');

                return modalInstanceRecovery.opened.then(function () {

                    return vmwareFactory.connectvCenterSoap(current_restore.esxi_credential, current_restore.esxi_address, current_restore.esxi_port);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to connect to vCenter');

                    return backupsmFactory.unmountDatastore(current_restore);
                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to unmount volume');

                    return backupsmFactory.destroyVolume(current_restore);
                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to destroy volume');

                    modalFactory.changeModalText('Saving results...', '.window--backupsm .window__main');
                    return backupsmFactory.setRestoreStatus(current_restore, 'init');
                }).then(function () {
                    return modalInstanceRecovery.close();

                }).catch(function (e) {
                    modalInstanceRecovery.close();

                    console.log(e);
                    return ApplicationsFactory.errorHandler(e.message);
                });

            };

            this.setActive = function (restore) {
                _this.showNewBackupType = false;
                _this.showRestore = true;
                return backupsmFactory.setActive(restore.uuid);
            };

            this.doDatastoreBackup = function () {
                vmwareFactory.getVMState('vm-322', true).then(function (data) {

                });
            };

        }]);
}());
(function () {
    'use strict';
    backupsmApp.factory('backupsmFactory', ['$injector', '$filter', '$q', '$log', 'uuid', 'netappFactory', 'vmwareFactory', 'ServerFactory', 'ApplicationsFactory', 'connectionsFactory', 'modalFactory',
        function ($injector, $filter, $q, $log, uuid, netappFactory, vmwareFactory, ServerFactory, ApplicationsFactory, connectionsFactory, modalFactory) {

            var backups = [];
            var restores = [];
            var active;

            /**
             * -------------------
             * PRIVATE FUNCTIONS
             * -------------------
             */

            /**
             * @description
             * Checks if NetApp storage have required licenses
             */
            var checkLicenses = function (data) {
                $log.debug('Backups Manager [%s] -> Cloning storage licenses -> storage [%s]', data.uuid, data.netapp_host);
                return netappFactory.getLicenses(
                    data.netapp_credential,
                    data.netapp_host,
                    data.netapp_port
                ).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get licenses');

                    var flexClone = $filter('filter')(res.data, {
                        'package': 'flexclone'
                    })[0].method;

                    if (flexClone !== 'license') throw new Error('FlexClone license not found');

                }).catch(function (e) {
                    console.log(e);
                    return e;
                });
            };

            /**
             * @description
             * Returns snapshot object given snapshot uuid
             *
             * @param data {Object}
             */
            var getSnapshotName = function (data) {
                return $filter('filter')(data.snapshots, {
                    'snapshot-instance-uuid': data.snapshot
                })[0].name;
            };

            /**
             * @description
             * Return the latest VM snapshot
             *
             * @param rootSnapshotList {Object}
             */
            var getLastSnapshot = function (rootSnapshotList) {
                if (rootSnapshotList.hasOwnProperty('childSnapshotList')) return getLastSnapshot(rootSnapshotList.childSnapshotList);

                return rootSnapshotList;
            };

            /**
             * goToSnapshot
             *
             * @description
             * Checks if VM have a snapshot called 'SysOS_backup_*' and if exists reverts the VM to this snapshot
             *
             * @param data {Object}
             */
            var goToSnapshot = function (data) {
                var last_snapshot;

                $log.debug('Backups Manager [%s] -> Get all VM snapshots -> vm [%s]', data.uuid, data.vm.vm);
                return vmwareFactory.getVMSnapshots(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get VM Snapshots');

                    // No snapshots found
                    if (!res.data[0].propSet) {
                        $log.debug('Backups Manager [%s] -> No snapshots found -> vm [%s]', data.uuid, data.vm.vm);
                        return res;
                    }

                    last_snapshot = getLastSnapshot(res.data[0].propSet.snapshot.rootSnapshotList);

                    if (last_snapshot.name.startsWith('SysOS_backup_')) {
                        $log.debug('Backups Manager [%s] -> Reverting VM to snapshot -> snapshot [%s]', data.uuid, last_snapshot.snapshot.name);
                        return vmwareFactory.revertToSnapshot(data.esxi_credential, data.esxi_address, data.esxi_port, last_snapshot.snapshot.name);
                    }

                    $log.debug('Backups Manager [%s] -> Last snapshot is not from SysOS backup -> snapshot [%s], snapshot_id [%s]', data.uuid, last_snapshot.name, last_snapshot.snapshot.name);
                    return res;

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get VM Snapshots');

                    // No snapshots found
                    if (!last_snapshot) return res;

                    if (last_snapshot.name.startsWith('SysOS_backup_')) {
                        $log.debug('Backups Manager [%s] -> Deleting VM snapshot -> snapshot [%s]', data.uuid, last_snapshot.snapshot.name);
                        return vmwareFactory.removeSnapshot(data.esxi_credential, data.esxi_address, data.esxi_port, last_snapshot.snapshot.name, true);
                    }

                    return res;

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to delete VM Snapshot');

                    return res;

                }).catch(function (e) {
                    console.log(e);
                    return e;
                });
            };

            /**
             * @description
             * Clones Storage Volume from Snapshot
             *
             * @param data {Object}
             */
            var cloneVolumeFromSnapshot = function (data) {

                if (data.volumeNum) {
                    data.volumeName = 'SysOS_' + data.volume['volume-id-attributes'].name + '_Restore_' + data.volumeNum;
                    data.datastorePath = 'SysOS_' + data.volume['volume-id-attributes'].name + '_' + data.volumeNum;
                } else {
                    data.volumeNum = 0;
                    data.volumeName = 'SysOS_' + data.volume['volume-id-attributes'].name + '_Restore';
                    data.datastorePath = 'SysOS_' + data.volume['volume-id-attributes'].name;
                }

                // Create Volume Clone
                $log.debug('Backups Manager [%s] -> Cloning volume from snapshot -> vserver [%s], volume [%s], snapshot [%s], volumeName [%s]', data.uuid, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name, getSnapshotName(data), data.volumeName);
                return netappFactory.cloneVolumeFromSnapshot(
                    data.netapp_credential,
                    data.netapp_host,
                    data.netapp_port,
                    data.vserver['vserver-name'],
                    data.volume['volume-id-attributes'].name,
                    data.volumeName,
                    getSnapshotName(data)
                ).then(function (res) {
                    if (res.status === 'error') {

                        // Error duplicated volume, try next.
                        if (res.error.errno === '17') throw new Error(17);

                        throw new Error('Failed to clone Volume');
                    }

                    return setRestoreStatus(data, 'volume_cloned');
                }).then(function () {

                    // Mount Volume Point
                    $log.debug('Backups Manager [%s] -> Mounting cloned volume -> vserver [%s], volume [%s]', data.uuid, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name);
                    return netappFactory.mountVolume(
                        data.netapp_credential,
                        data.netapp_host,
                        data.netapp_port,
                        data.vserver['vserver-name'],
                        data.volumeName,
                        '/' + data.volumeName
                    );

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to mount Volume');

                    return setRestoreStatus(data, 'namespace_mounted');

                }).catch(function (e) {

                    // Error duplicated volume, try next.
                    if (e.message === '17') {
                        $log.debug('Backups Manager [%s] -> Cloning volume from snapshot -> vserver [%s], volume [%s], snapshot [%s], volumeName [%s] -> Volume with same name found', data.uuid, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name, getSnapshotName(data), data.volumeName);

                        ++data.volumeNum;
                        return cloneVolumeFromSnapshot(data);
                    }

                    console.log(e);
                    return e;
                });
            };

            /**
             * @description
             * Mount storage Datastore to ESXi host
             *
             * @param data {Object}
             */
            var mountVolumeToESXi = function (data) {

                // TODO: check Storage EXPORTS
                // TODO: Create export

                /*
                <?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'>
<netapp version='1.15' xmlns='http://www.netapp.com/filer/admin' vfiler='LABSVM'><export-rule-create><client-match>192.168.4.145</client-match><policy-name>default</policy-name><ro-rule><security-flavor>any</security-flavor></ro-rule><rw-rule><security-flavor>never</security-flavor></rw-rule><rule-index>1</rule-index><super-user-security><security-flavor>any</security-flavor></super-user-security></export-rule-create></netapp>
                 */
                $log.debug('Backups Manager [%s] -> Get Volume Exports -> vserver [%s], volume [%s], volumeName [%s]', data.uuid, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name, data.volumeName);
                return netappFactory.getNFSExportRulesList(
                    data.netapp_credential,
                    data.netapp_host,
                    data.netapp_port,
                    data.vserver['vserver-name'],
                    data.volume['volume-id-attributes'].name
                ).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get Volume Exports');

                    console.log(res);

                    // Check export that allows "all-hosts"
                    var allHostsExport = $filter('filter')(res.data["exports-rule-info-2"]["security-rules"]["security-rule-info"], {
                        "read-write": {
                            "exports-hostname-info": {
                                "all-hosts": true
                            }
                        }
                    });

                    var esxiHostExport = $filter('filter')(res.data["exports-rule-info-2"]["security-rules"]["security-rule-info"], {
                        "read-write": {
                            "exports-hostname-info": {
                                "name": data.netapp_nfs_ip[0].address
                            }
                        }
                    });

                    console.log(data);
                    console.log(allHostsExport);
                    console.log(esxiHostExport);

                    $log.debug('Backups Manager [%s] -> Connection to vCenter using SOAP -> vCenter [%s]', data.uuid, data.esxi_address);
                    return vmwareFactory.connectvCenterSoap(data.esxi_credential, data.esxi_address, data.esxi_port);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to connect to vCenter');

                    // TODO: check connectivity from NFS node
                    return vmwareFactory.getHostConfigManagerNetworkSystem(data.esxi_credential, data.esxi_address, data.esxi_port, data.esxi_host);

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get networkSystem from vCenter');

                    data.networkSystem = res.data;

                    // Get Datastore System from ESXi host to mount
                    $log.debug('Backups Manager [%s] -> Getting datastore system -> host [%s]', data.uuid, data.esxi_host);
                    return vmwareFactory.getHostConfigManagerDatastoreSystem(data.esxi_credential, data.esxi_address, data.esxi_port, data.esxi_host);

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get datastoreSystem from vCenter');

                    data.datastoreSystem = res.data;

                    // TODO: check connectivity from NFS node
                    return vmwareFactory.getHostNetworkInfoVnic(data.esxi_credential, data.esxi_address, data.esxi_port, data.networkSystem);

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get NetworkInfoVnic from vCenter');

                    // TODO: check connectivity from NFS node
                    return vmwareFactory.getHostNetworkInfoConsoleVnic(data.esxi_credential, data.esxi_address, data.esxi_port, data.networkSystem);

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get NetworkInfoConsoleVnic from vCenter');

                    $log.debug('Backups Manager [%s] -> Mount volume to ESXi -> datastoreSystem [%s], nfs_ip [%s], volume [%s], path [%s]', data.uuid, data.datastoreSystem, data.netapp_nfs_ip[0].address, '/' + data.volumeName + '/', data.datastorePath);
                    return vmwareFactory.mountDatastore(
                        data.esxi_credential,
                        data.esxi_address,
                        data.esxi_port,
                        data.datastoreSystem,
                        data.netapp_nfs_ip[0].address,
                        '/' + data.volumeName + '/',
                        data.datastorePath
                    );

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to mount Datastore to host');

                    // Get mounted datastore name
                    data.esxi_datastore = res.data;
                    return setRestoreStatus(data, 'mounted_to_esx');

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get Datastore Properties from vCenter');

                }).catch(function (e) {
                    console.log(e);
                    return e;
                });
            };

            /**
             * @description
             * Register and power on VM
             *
             * @param data {Object}
             */
            var registerVM = function (data) {

                data.vm.path = data.vm.summary.config.vmPathName.split(']').pop();
                data.vm.path = data.vm.path.substring(0, data.vm.path.lastIndexOf('/') + 1).substr(1);

                // Get VM in Datastore (check if exist)
                return vmwareFactory.getVMFileDataFromDatastore(
                    data.esxi_credential,
                    data.esxi_address,
                    data.esxi_port,
                    data.esxi_datastore,
                    data.datastorePath,
                    data.vm.path,
                    data.vm.summary.config.vmPathName.split('/').pop()
                ).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get files from datastore');
                    if (res.data[0].propSet.info.error) throw new Error(res.data[0].propSet.info.error);

                    // Register VM
                    //TODO: check if VM with same name exists
                    $log.debug('Backups Manager [%s] -> Register VM to ESXi -> host [%s], vmx_file [%s], vm_name [%s], folder [%s], resource_pool [%s]', data.uuid, data.esxi_host, '[' + data.datastorePath + '] ' + data.vm.summary.config.vmPathName.split(']').pop(), data.vm.name, data.folder, data.resource_pool);
                    return vmwareFactory.registerVM(
                        data.esxi_credential,
                        data.esxi_address,
                        data.esxi_port,
                        data.esxi_host,
                        '[' + data.datastorePath + '] ' + data.vm.summary.config.vmPathName.split(']').pop().substr(1),
                        data.vm.name,
                        data.folder,
                        data.resource_pool
                    );

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to register VM to vCenter');

                    setRestoreStatus(data, 'vm_registred');

                    data.vm.vm = res.data.result.name;

                    // Set new uuid to this VM to prevent duplicates
                    var newVMUuid = uuid.v4();
                    data.vm.config.uuid = newVMUuid;
                    $log.debug('Backups Manager [%s] -> Reconfigure VM uuid -> vm_name [%s], newVMUuid [%s]', data.vm.name, newVMUuid);
                    return vmwareFactory.reconfigureVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm, '<uuid>' + newVMUuid + '</uuid>');
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to change VM uuid');

                    return goToSnapshot(data);

                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to revert VM to Snapshot');

                }).catch(function (e) {
                    console.log(e);
                    return e;
                });

            };

            /**
             * @description
             * Restore a VM from Snapshot to same location (override)
             *
             * @param data {Object}
             */
            var restoreVMfromSnapshotToCurrentLocation = function (data) {
                var sfr_promises = [];
                var vm_path;

                $log.debug('Backups Manager [%s] -> Connection to vCenter using SOAP -> vCenter [%s]', data.uuid, data.esxi_address);
                return vmwareFactory.connectvCenterSoap(data.esxi_credential, data.esxi_address, data.esxi_port).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to connect to vCenter');

                    $log.debug('Backups Manager [%s] -> Get VM path -> VM [%s]', data.uuid, data.vm.vm);
                    return vmwareFactory.getVMPath(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);
                }).then(function (res) {
                    if (res && res.status === 'error') throw new Error('Failed to get VM path');

                    var regex = /\[*\]\s(.*)\/.*\.vmx/gi;
                    var str = res.data.propSet['config.files.vmPathName'];

                    vm_path = regex.exec(str)[1];

                    if (!vm_path) throw new Error('SAFETY STOP: VM cannot be on root folder');

                    $log.debug('Backups Manager [%s] -> Get VM runtime -> VM [%s]', data.uuid, data.vm.vm);
                    return vmwareFactory.getVMRuntime(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);
                }).then(function (res) {
                    if (res && res.status === 'error') throw new Error('Failed to get VM runtime');

                    if (res.data.propSet.runtime.powerState === 'poweredOn') {
                        $log.debug('Backups Manager [%s] -> Powering off VM -> VM [%s]', data.uuid, data.vm.vm);
                        return vmwareFactory.powerOffVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);
                    }

                    return res;

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to power off VM at vCenter');

                    $log.debug('Backups Manager [%s] -> Get snapshot files from storage -> storage [%s], vserver [%s], volume [%s], snapshot [%s], path [%s]', data.uuid, data.netapp_host, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name, getSnapshotName(data), '/' + vm_path);
                    return netappFactory.getSnapshotFiles(
                        data.netapp_credential,
                        data.netapp_host,
                        data.netapp_port,
                        data.vserver['vserver-name'],
                        data.volume['volume-id-attributes'].name,
                        getSnapshotName(data),
                        '/' + vm_path
                    );
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get Snapshot files');

                    angular.forEach(res.data, function (file) {
                        if (file.name.indexOf('.lck') >= 0) return;

                        sfr_promises.push(netappFactory.snapshotRestoreFile(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name, getSnapshotName(data), '/vol/' + data.volume['volume-id-attributes'].name + '/' + vm_path + '/' + file.name).then(function (res) {
                            $log.debug('Backups Manager [%s] -> Restoring file from storage snapshot -> storage [%s], vserver [%s], volume [%s], snapshot [%s], path [%s]', data.uuid, data.netapp_host, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name, getSnapshotName(data), '/vol/' + data.volume['volume-id-attributes'].name + '/' + vm_path + '/' + file.name);
                            if (res.status === 'error') throw new Error('Failed to restore file from storage snapshot');
                        }));
                    });

                    return $q.all(sfr_promises);

                }).then(function () {

                    $log.debug('Backups Manager [%s] -> Reloading VM -> VM [%s]', data.uuid, data.vm.vm);
                    return vmwareFactory.reloadVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to reload VM');

                    return goToSnapshot(data);

                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to revert VM to Snapshot');

                    return res;

                }).catch(function (e) {
                    console.log(e);
                    return e;
                });
            };

            /**
             * -------------------
             * PUBLIC FUNCTIONS
             * -------------------
             */

            /*
             *   Keeps a track of backup point and updates it to backend.
             */
            var setBackupStatus = function (data, status) {
                $filter('filter')(backups, {uuid: data.uuid})[0].status.push(status);

                return ServerFactory.saveConfigToFile(data, 'applications/backupsm/backups.json', false);
            };

            /*
             *   Keeps a track of restore point and updates it to backend.
             */
            var setRestoreStatus = function (data, status) {
                $filter('filter')(restores, {uuid: data.uuid})[0].status.push(status);

                return ServerFactory.saveConfigToFile(data, 'applications/backupsm/restores.json', false);
            };

            /*
             * mountRestoreSnapshotDatastore
             */
            var mountRestoreSnapshotDatastore = function (data) {

                // Check for available licenses
                return checkLicenses(data).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to check licenses');

                    // Create Volume Clone
                    return cloneVolumeFromSnapshot(data);
                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to clone volume from snapshot');

                    // Mount Volume
                    return mountVolumeToESXi(data);

                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to mount cloned volume from snapshot to ESXi host');

                }).catch(function (e) {
                    console.log(e);
                    return e;
                });

            };

            /*
             * restoreSnapshotDatastoreFiles
             */
            var restoreSnapshotDatastoreFiles = function (data) {

                // Check for available licenses
                return checkLicenses(data).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to check licenses');

                    // Create Volume Clone
                    return cloneVolumeFromSnapshot(data);
                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to clone volume from snapshot');

                    // Mount Volume
                    return mountVolumeToESXi(data);

                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to mount cloned volume from snapshot to ESXi host');

                }).catch(function (e) {
                    console.log(e);
                    return e;
                });

            };

            /*
             * restoreSnapshotVMGuestFiles
             */
            var restoreSnapshotVMGuestFiles = function (data) {

                // Check for available licenses
                return checkLicenses(data).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to check licenses');

                    // Create Volume Clone
                    return cloneVolumeFromSnapshot(data);
                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to clone volume from snapshot');

                    // Mount Volume
                    return mountVolumeToESXi(data);

                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to mount cloned volume from snapshot to ESXi host');

                    return registerVM(data);

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to register VM to vCenter');
                    return res;


                }).catch(function (e) {
                    return e;
                });

            };

            /*
             * restoreSnapshotVMInstantMachine
             */
            var restoreSnapshotIntoInstantVM = function (data) {

                // Check for available licenses
                return checkLicenses(data).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to check licenses');

                    // Create Volume Clone
                    return cloneVolumeFromSnapshot(data);
                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to clone volume from snapshot');

                    // Mount Volume
                    return mountVolumeToESXi(data);

                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to mount cloned volume from snapshot to ESXi host');

                    return registerVM(data);

                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to register VM from snapshot to ESXi host');

                    if (data.vm_power_on) {
                        // Power On VM
                        $log.debug('Backups Manager [%s] -> Powering on vm -> host [%s], VM [%s], ', data.uuid, data.esxi_host, data.vm.vm);
                        return vmwareFactory.powerOnVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.esxi_host, data.vm.vm);
                    }

                    return res;

                }).then(function (res) {
                    if (res && res.status === 'error') throw new Error('Failed to power on VM on vCenter');

                    return res;

                }).catch(function (e) {
                    console.log(e);
                    return e;
                });

            };

            /*
             * restoreSnapshotIntoVM
             */
            var restoreSnapshotIntoVM = function (data) {

                //TODO: if new location
                /*return cloneVMFromSnapshot(data).then(function (data) {

                 });*/

                // Restore to current location (override VM)
                return restoreVMfromSnapshotToCurrentLocation(data).then(function (data) {

                    if (data.vm_power_on) {
                        // Power On VM
                        $log.debug('Backups Manager [%s] -> Powering on vm -> host [%s], VM [%s], ', data.uuid, data.esxi_host, data.vm.vm);
                        return vmwareFactory.powerOnVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.esxi_host, data.vm.vm);
                    }

                }).then(function (res) {
                    if (res instanceof Error) throw new Error('Failed to restore VM snapshot to current location');

                }).catch(function (e) {
                    console.log(e);
                    return e;
                });
            };

            /*
             * Unpublish VM
             */
            var unpublishVM = function (data) {

                modalFactory.changeModalText('Connecting to vCenter...', '.window--backupsm .window__main');
                return vmwareFactory.connectvCenterSoap(data.esxi_credential, data.esxi_address, data.esxi_port).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to connect to vCenter');

                    // Check if VM is powered on
                    return vmwareFactory.getVMState(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get VM state from vCenter');

                    // VM not found
                    if (res && res.data.hasOwnProperty('ManagedObjectNotFoundFault')) return res;

                    // Power Off VM
                    if (res.data['runtime.powerState'] === 'poweredOn') {
                        modalFactory.changeModalText('PLEASE WAIT', 'Powering off VM ...', '.window--backupsm .window__main');
                        return vmwareFactory.powerOffVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);
                    }

                    // VM is Powered Off
                    return res;

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to power off VM at vCenter');

                    // VM not found
                    if (res && res.data.hasOwnProperty('ManagedObjectNotFoundFault')) return res;

                    // Unregister VM
                    modalFactory.changeModalText('Unregistering VM ...', '.window--backupsm .window__main');
                    return vmwareFactory.unregisterVM(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);

                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to unregister VM from vCenter');

                    return setRestoreStatus(data, 'mounted_to_esx');
                }).catch(function (e) {
                    console.log(e);
                    return e;
                });

            };

            /*
             * Unmount Datastore
             */
            var unmountDatastore = function (data) {

                // Unregister Datastore
                modalFactory.changeModalText('Unmounting datastore...', '.window--backupsm .window__main');
                return vmwareFactory.unmountDatastore(data.esxi_credential, data.esxi_address, data.esxi_port, data.datastoreSystem, data.esxi_datastore).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to unmount datastore from vCenter');

                    return setRestoreStatus(data, 'namespace_mounted');
                }).catch(function (e) {
                    console.log(e);
                    return e;
                });

            };

            /**
             * Destroy Storage Volume
             */
            var destroyVolume = function (data) {

                // Unmount NetApp Volume
                modalFactory.changeModalText('Unmounting storage volume...', '.window--backupsm .window__main');
                return netappFactory.unmountVolume(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver['vserver-name'], data.volumeName).then(function (res) {
                    if (res.status === 'error' || res.data !== 'passed') throw new Error('Failed to unmount volume');

                    return setRestoreStatus(data, 'volume_cloned');
                }).then(function () {

                    // Set NetApp Volume Offline
                    modalFactory.changeModalText('Setting volume offline...', '.window--backupsm .window__main');
                    return netappFactory.setVolumeOffline(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver['vserver-name'], data.volumeName);

                }).then(function (res) {
                    if (res.status === 'error' || res.data !== 'passed') throw new Error('Failed to set volume offline');

                    return setRestoreStatus(data, 'volume_offline');
                }).then(function () {

                    // Destroy NetApp Volume
                    modalFactory.changeModalText('Destroying volume...', '.window--backupsm .window__main');
                    return netappFactory.destroyVolume(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver['vserver-name'], data.volumeName);

                }).then(function (res) {
                    if (res.status === 'error' || res.data !== 'passed') throw new Error('Failed to destroy volume');

                }).catch(function (e) {
                    console.log(e);
                    return e;
                });
            };

            /*
             * create SnapShot
             */
            var createSnapShot = function () {

            };

            /*
             * Backup
             */
            var startVMBackup = function (data) {
                var _this = this;
                var relationships = {};
                var main_promises = [];
                var datastore_promises = [];
                var ss_promises = [];
                var ssr_promises = [];

                this.connections = connectionsFactory.connections();

                // Start backup
                if (data.backupNow === true && data.selectedPrimaryStorage === 'snapshot') {

                    $log.debug('Backups Manager [%s] -> Running backup now -> name [%s]', data.uuid, data.backupName);

                    // Get all relationships
                    angular.forEach(data.selectedObjects, function (object) {

                        if (object.type === 'vCenter') {
                            // TODO: Get all valid Datastores in vCenter
                            // TODO: Make a backup for every VM in a valid datastore
                        }

                        if (object.type === 'Datastore') {
                            // TODO: Make a backup for every VM in datastore
                        }

                        if (object.type === 'Datacenter') {
                            // TODO: Get all valid VMs in Datacenter
                            // TODO: remove VMs in previous selected Datastores
                            // TODO: Make a backup for every VM in valid datastore
                        }

                        if (object.type === 'Cluster') {
                            // TODO: Get all valid VMs in Cluster
                            // TODO: remove VMs in previous selected Datastores
                            // TODO: Make a backup for every VM in valid datastore
                        }

                        if (object.type === 'VirtualMachine') {

                            // TODO: remove VMs in previous selected objects

                            // TODO: VM with more than 1 datastore
                            if (Array.isArray(object.object.datastore.ManagedObjectReference)) return;

                            if (data.quiesceTools) {
                            }

                            if (!relationships[object.parent]) relationships[object.parent] = {};
                            if (!relationships[object.parent][object.object.datastore.ManagedObjectReference.name]) relationships[object.parent][object.object.datastore.ManagedObjectReference.name] = [];

                            relationships[object.parent][object.object.datastore.ManagedObjectReference.name].push({
                                vm: object.id,
                                state: object.object.runtime.powerState,
                                type: 'VirtualMachine'
                            });

                        }
                    });

                    // For each vCenter
                    angular.forEach(relationships, function (datastores, vCenter) {

                        var connection = connectionsFactory.getConnectionByUuid(vCenter);
                        var esxi_credential = connection.credential;
                        var esxi_address = connection.host;
                        var esxi_port = connection.port;
                        var task_id;

                        $log.debug('Backups Manager [%s] -> Connecting to vCenter -> vCenter [%s]', data.uuid, esxi_address);
                        main_promises.push(vmwareFactory.connectvCenterSoap(esxi_credential, esxi_address, esxi_port).then(function (res) {
                            if (res.status === 'error') throw new Error('Failed to connect to vCenter');

                            return vmwareFactory.createTask(esxi_credential, esxi_address, esxi_port, 'com.sysos.management.backup', 'Datacenter', 'group-d1');

                        }).then(function (res) {
                            if (res.status === 'error') throw new Error('Failed to create task');
                            $log.debug('Backups Manager [%s] -> Main task created -> vCenter [%s], task [%s]', data.uuid, esxi_address, res.data.key);

                            task_id = res.data.key;

                            return vmwareFactory.setTaskState(esxi_credential, esxi_address, esxi_port, task_id, 'running');
                        }).then(function (res) {
                            if (res.status === 'error') throw new Error('Failed to set task state');
                            $log.debug('Backups Manager [%s] -> Main task running -> vCenter [%s], task [%s]', data.uuid, esxi_address, task_id);

                            return vmwareFactory.updateTaskProgress(esxi_credential, esxi_address, esxi_port, task_id, 20);
                        }).then(function (res) {
                            if (res.status === 'error') throw new Error('Failed to update task progress');
                            $log.debug('Backups Manager [%s] -> Main task 20% -> vCenter [%s], task [%s]', data.uuid, esxi_address, task_id);

                            // Backup for each Datstore
                            angular.forEach(datastores, function (objects, datastore) {

                                var datastore_task_id;

                                datastore_promises.push(vmwareFactory.createTask(esxi_credential, esxi_address, esxi_port, 'com.sysos.management.backup', 'Datastore', datastore).then(function (res) {
                                    if (res.status === 'error') throw new Error('Failed to create task');
                                    $log.debug('Backups Manager [%s] -> Datastore task created -> vCenter [%s], datastore [%s], task [%s]', data.uuid, esxi_address, datastore, res.data.key);

                                    datastore_task_id = res.data.key;

                                    return vmwareFactory.setTaskState(esxi_credential, esxi_address, esxi_port, datastore_task_id, 'running');
                                }).then(function (res) {
                                    if (res.status === 'error') throw new Error('Failed to set task state');
                                    $log.debug('Backups Manager [%s] -> Datastore task running -> vCenter [%s], task [%s]', data.uuid, esxi_address, datastore_task_id);

                                    return vmwareFactory.updateTaskProgress(esxi_credential, esxi_address, esxi_port, datastore_task_id, 20);
                                }).then(function (res) {
                                    if (res.status === 'error') throw new Error('Failed to update task progress');
                                    $log.debug('Backups Manager [%s] -> Datastore task 20% -> vCenter [%s], task [%s]', data.uuid, esxi_address, datastore_task_id);

                                    var smanagerFactory = $injector.get('smanagerFactory');

                                    var storage_link = smanagerFactory.getLinkByVMwareDatastore(vCenter, datastore);

                                    if (!storage_link) throw new Error('Unable to get Storage Link');

                                    var storage = connectionsFactory.getConnectionByUuid(storage_link.storage);
                                    var vserver = eval(connectionsFactory.getObjectByUuidMapping(storage_link.vserver)); // jshint ignore:line
                                    var volume = eval(connectionsFactory.getObjectByUuidMapping(storage_link.volume)); // jshint ignore:line

                                    if (!storage) throw new Error('Unable to get Storage object');
                                    if (!vserver) throw new Error('Unable to get Vserver object');
                                    if (!volume) throw new Error('Unable to get Volume object');

                                    var netapp_credential = storage.credential;
                                    var netapp_host = storage.host;
                                    var netapp_port = storage.port;
                                    var snapshots = [];

                                    angular.forEach(objects, function (key) {

                                        /*
                                         * Create VM Snapshot if vm state is poweredOn
                                         */
                                        if (key.state === 'poweredOn') {
                                            $log.debug('Backups Manager [%s] -> Creating VM snapshot -> VM [%s]', data.uuid, key.vm);

                                            ss_promises.push(vmwareFactory.createSnapShot(esxi_credential, esxi_address, esxi_port, key.vm, 'SysOS_backup_' + data.uuid, 'SysOS temporary snapshot. Do not delete this snapshot while a backup is running.', false, true).then(function (res) {
                                                if (res.status === 'error') throw new Error('Failed to create snapshot');
                                                if (res.data[0].propSet.info.error) throw new Error('Failed to create snapshot');

                                                $log.debug('Backups Manager [%s] -> VM snapshot created -> vCenter [%s], vm [%s], snapshot [%s]', data.uuid, esxi_address, key.vm, res.data[0].propSet.info.result.name);

                                                snapshots.push(res.data[0].propSet.info.result.name);

                                            }).catch(function (e) {
                                                console.log(e);
                                                return e;
                                            }));
                                        } else {
                                            $log.debug('Backups Manager [%s] -> VM poweredOff, do not create snapshot -> VM [%s]', data.uuid, key.vm);
                                        }

                                    });
                                    //End VM each

                                    return $q.all(ss_promises).then(function () {

                                        return vmwareFactory.updateTaskProgress(esxi_credential, esxi_address, esxi_port, datastore_task_id, 40);
                                    }).then(function (res) {
                                        if (res.status === 'error') throw new Error('Failed to update task progress');
                                        $log.debug('Backups Manager [%s] -> Datastore task 40% -> vCenter [%s], task [%s]', data.uuid, esxi_address, datastore_task_id);

                                        /*
                                         * Create Storage Snapshot
                                         */
                                        return netappFactory.createSnapshot(netapp_credential, netapp_host, netapp_port, vserver['vserver-name'], volume['volume-id-attributes'].name, data.backupName);

                                    }).then(function (res) {
                                        if (res.status === 'error') throw new Error('Failed to create Volume Snapshot');
                                        $log.debug('Backups Manager [%s] -> Storage snapshot created -> vCenter [%s], storage [%s], vserver [%s], volume [%s]', data.uuid, esxi_address, netapp_host, vserver['vserver-name'], volume['volume-id-attributes'].name);

                                        return vmwareFactory.updateTaskProgress(esxi_credential, esxi_address, esxi_port, datastore_task_id, 60);
                                    }).then(function (res) {
                                        if (res.status === 'error') throw new Error('Failed to update task progress');
                                        $log.debug('Backups Manager [%s] -> Datastore task 60% -> vCenter [%s], task [%s]', data.uuid, esxi_address, datastore_task_id);

                                        /*
                                         * Delete VM Snapshot
                                         */
                                        angular.forEach(snapshots, function (snapshot) {
                                            ssr_promises.push(vmwareFactory.removeSnapshot(esxi_credential, esxi_address, esxi_port, snapshot, false).then(function (res) {
                                                if (res.status === 'error') throw new Error('Failed to delete snapshot');
                                                $log.debug('Backups Manager [%s] -> VM snapshot deleted -> vCenter [%s], snapshot [%s]', data.uuid, esxi_address, snapshot);

                                            }).catch(function (e) {
                                                console.log(e);
                                                return e;
                                            }));
                                        });
                                        //End Snapshots each

                                        return $q.all(ssr_promises);

                                    }).then(function () {
                                        return vmwareFactory.updateTaskProgress(esxi_credential, esxi_address, esxi_port, datastore_task_id, 80);
                                    }).then(function (res) {
                                        if (res.status === 'error') throw new Error('Failed to update task progress');
                                        $log.debug('Backups Manager [%s] -> Datastore task 80% -> vCenter [%s], task [%s]', data.uuid, esxi_address, datastore_task_id);

                                        // End Task
                                        return vmwareFactory.setTaskState(esxi_credential, esxi_address, esxi_port, datastore_task_id, 'success');

                                    }).then(function (res) {
                                        if (res.status === 'error') throw new Error('Failed to set task state');
                                        $log.debug('Backups Manager [%s] -> Datastore task success -> vCenter [%s], task [%s]', data.uuid, esxi_address, datastore_task_id);

                                    }).catch(function (e) {
                                        console.log(e);
                                        return e;
                                    });

                                }));

                            });
                            //End Datastore each

                            // End vCenter backup task
                            return $q.all(datastore_promises).then(function () {

                                return vmwareFactory.updateTaskProgress(esxi_credential, esxi_address, esxi_port, task_id, 80);

                            }).then(function (res) {
                                if (res.status === 'error') throw new Error('Failed to update task progress');
                                $log.debug('Backups Manager [%s] -> Main task 80% -> vCenter [%s], task [%s]', data.uuid, esxi_address, task_id);

                                // End Task
                                return vmwareFactory.setTaskState(esxi_credential, esxi_address, esxi_port, task_id, 'success');
                            }).then(function (res) {
                                if (res.status === 'error') throw new Error('Failed to set task state');
                                $log.debug('Backups Manager [%s] -> Main task success -> vCenter [%s], task [%s]', data.uuid, esxi_address, task_id);

                            }).catch(function (e) {
                                console.log(e);
                                return e;
                            });

                        }));
                    });
                    // End vCenter each

                    return $q.all(main_promises).catch(function (e) {
                        console.log(e);
                        return e;
                    });

                }

                //TODO:
                /*return vmwareFactory.connectvCenterSoap(data.esxi_credential, data.esxi_address, data.esxi_port).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to connect to vCenter');

                    return vmwareFactory.getVMState(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm, true);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get VM data');

                    console.log('getVMState', res);
                    return vmwareFactory.getDatastores(data.esxi_credential, data.esxi_address, data.esxi_port, 'group-d1');
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get datastores');

                    console.log('getDatastores', res);
                    return vmwareFactory.getDatastoresWithVMsData(data.esxi_credential, data.esxi_address, data.esxi_port, 'group-d1');
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get datastores with VM data');

                    console.log('getDatastoresWithVMsData', res);
                    return vmwareFactory.getDatastoreProps(data.esxi_credential, data.esxi_address, data.esxi_port, 'datastore-321');
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get datastore');

                    console.log('getDatastoreProps', res);
                    return vmwareFactory.getFilesDataFromDatastore(data.esxi_credential, data.esxi_address, data.esxi_port, 'datastore-321', 'NFS_MAD', 'tt');
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get files from datastores');

                    console.log('getFilesDataFromDatastore', res);
                    return vmwareFactory.queryVMEvents(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to query VM events');

                    console.log('queryVMEvents', res);
                    return vmwareFactory.searchIndexVM(data.esxi_credential, data.esxi_address, data.esxi_port, '502197e9-abe7-06e7-7d88-667c0a8b01ea');
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to searchIndex');

                    console.log('searchIndex', res);
                    return vmwareFactory.createTask(data.esxi_credential, data.esxi_address, data.esxi_port, 'com.sysos.management.backup', 'VirtualMachine', data.vm.vm);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to create task');

                    console.log('createTask', res);

                    task_id = res.data.key;

                    return vmwareFactory.setTaskState(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 'running');
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to set task state');

                    console.log('setTaskState', res);
                    return vmwareFactory.updateTaskProgress(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 20);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to update task progress');

                    console.log('updateTaskProgress', res);
                    return vmwareFactory.searchIndexVM(data.esxi_credential, data.esxi_address, data.esxi_port, '502197e9-abe7-06e7-7d88-667c0a8b01ea');
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to searchIndex');

                    console.log('searchIndex', res);
                    return vmwareFactory.getVMs(data.esxi_credential, data.esxi_address, data.esxi_port, 'group-d1');
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to get VMs');

                    console.log('getVMs', res);
                    return vmwareFactory.createSnapShot(data.esxi_credential, data.esxi_address, data.esxi_port, data.vm.vm, 'SysOS_backup_' + data.uuid, 'SysOS temporary snapshot. Do not delete this snapshot while a backup is running.', false, true);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to create snapshot');

                    console.log('createSnapShot', res);

                    stanpshot = res.data[0].propSet.info.result.name;

                    return vmwareFactory.updateTaskProgress(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 40);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to update task progress');

                    console.log('updateTaskProgress', res);
                    return netappFactory.createSnapshot(data.netapp_credential, data.netapp_host, data.netapp_port, data.vserver['vserver-name'], data.volume['volume-id-attributes'].name);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to create Volume Snapshot');

                    console.log('createSnapShot', res);
                    return vmwareFactory.updateTaskProgress(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 60);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to update task progress');

                    console.log('updateTaskProgress', res);
                    return vmwareFactory.removeSnapshot(data.esxi_credential, data.esxi_address, data.esxi_port, stanpshot, false);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to delete snapshot');

                    console.log('removeSnapshot', res);
                    return vmwareFactory.updateTaskProgress(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 80);
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to update task progress');

                    console.log('updateTaskProgress', res);
                    return vmwareFactory.setTaskState(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 'success');
                }).then(function (res) {
                    if (res.status === 'error') throw new Error('Failed to set task state');

                    console.log('setTaskState', res);
                }).catch(function (e) {
                    console.log(e);

                    // Remove snapshot if exists on error and finish task
                    if (stanpshot) {
                        return vmwareFactory.removeSnapshot(data.esxi_credential, data.esxi_address, data.esxi_port, stanpshot, false).then(function () {
                            return vmwareFactory.setTaskState(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 'error');
                        }).catch(function (e) {
                            return vmwareFactory.setTaskState(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 'error');
                        });
                    }

                    // Finish task on error
                    if (task_id) return vmwareFactory.setTaskState(data.esxi_credential, data.esxi_address, data.esxi_port, task_id, 'error');

                });*/
            };

            return {
                setBackups: function (data) {
                    backups = data;
                },
                getBackups: function () {
                    return backups;
                },
                setRestores: function (data) {
                    restores = data;
                },
                getRestores: function () {
                    return restores;
                },
                getActive: function () {
                    return active;
                },
                setBackup: function (data) {
                    data.status = [];
                    return backups.push(data);
                },
                setRestore: function (data) {
                    data.status = [];
                    return restores.push(data);
                },
                setActive: function (uuid) {
                    return active = uuid;
                },
                setBackupStatus: setBackupStatus,
                setRestoreStatus: setRestoreStatus,
                mountRestoreSnapshotDatastore: mountRestoreSnapshotDatastore,
                restoreSnapshotVMGuestFiles: restoreSnapshotVMGuestFiles,
                restoreSnapshotDatastoreFiles: restoreSnapshotDatastoreFiles,
                restoreSnapshotIntoInstantVM: restoreSnapshotIntoInstantVM,
                restoreSnapshotIntoVM: restoreSnapshotIntoVM,
                unpublishVM: unpublishVM,
                unmountDatastore: unmountDatastore,
                destroyVolume: destroyVolume,
                createSnapShot: createSnapShot,
                startVMBackup: startVMBackup
            };
        }]);
}());
(function () {
	'use strict';
	backupsmApp.run(['$templateCache', function ($templateCache) {

		$templateCache.put('applications/backupsm/modals/backupWizard.html',
			'<div class="modal-header"> \
			  <div class="modal-title" id="modal-title">{{bwmC.title}}</div> \
			  <div class="window__controls window__controls--right"><a class="window__close" ng-click="bwmC.close(); $event.stopPropagation();"><i class="fa fa-close"></i></a></div> \
			</div> \
			<div class="modal-body modal-recovery-wizard" id="modal-body"> \
			  <div class="wizard"> \
				<ul class="nav nav-wizard"> \
				  <li ng-class="{\'active\': bwmC.step == 1}"> \
					<a ng-click="bwmC.step = 1">Name</a> \
				  </li> \
				  <li ng-class="{\'active\': bwmC.step == 2}"> \
					<a ng-click="bwmC.step = 2">Virtual Machines</a> \
				  </li> \
				  <li ng-class="{\'active\': bwmC.step == 3}"> \
					<a ng-click="bwmC.step = 3">Storage</a> \
				  </li> \
				  <li ng-class="{\'active\': bwmC.step == 4}"> \
					<a ng-click="bwmC.step = 4">Guest Processing</a> \
				  </li> \
				  <li ng-class="{\'active\': bwmC.step == 5}"> \
					<a ng-click="bwmC.step = 5">Schedule</a> \
				  </li> \
				  <li ng-class="{\'active\': bwmC.step == 6}"> \
					<a ng-click="bwmC.step = 6">Summary</a> \
			      </li>\
				</ul> \
				<form> \
				  <div class="tab-content"> \
				    <div class="tab-pane" ng-if="bwmC.step == 1" ng-class="{\'active\': bwmC.step == 1}"> \
				        <hr class="hr-text" data-content="Type in a name for this backup job"> \
				        <form> \
							<div class="form-group row"> \
								<label for="backupName" class="col-sm-2 col-form-label">Backup name</label> \
								<div class="col-sm-10"> \
									<input type="text" class="form-control" placeholder="name" ng-model="bwmC.backupName" autofocus/> \
								</div> \
							</div> \
						</form> \
					</div> \
					<div class="tab-pane" ng-if="bwmC.step == 2" ng-class="{\'active\': bwmC.step == 2}"> \
						<div class="row"> \
							<div class="col-sm-6 bar-right"> \
								<hr class="hr-text" data-content="Select objects"> \
								<h5>Select Virtual Machines to process via container or granularly. Container provides dynamic selection that automatically changes as you add new VM into container.</h5> \
					            <div ui-tree="" data-drag-enabled="false"> \
									<ol ui-tree-nodes="" ng-model="::bwmC.list"> \
										<li ng-repeat="item in ::bwmC.list" ui-tree-node collapsed="false" ng-include="\'applications/backupsm/modals/hierarchyItemsRenderer.html\'"></li> \
									</ol> \
								</div>\
					        </div> \
					        <div class="col-sm-6"> \
					            <hr class="hr-text" data-content="Selected objects ({{bwmC.selectedCount}})"> \
					            <table class="table table-hover m-t-xl"> \
					                <thead> \
					                    <tr> \
					                        <th>Name</th> \
					                        <th>Type</th> \
					                        <th>vCenter</th> \
					                    </tr> \
					                </thead> \
									<tbody> \
										<tr class="cursor-pointer" ng-repeat="item in bwmC.selectedObjects"> \
											<th class="col-sm-3"> \
												<i class="p-l-sm" ng-class="::{ \
													\'vs-icon vsphere-icon-vcenter\': item.type === \'vCenter\', \
													\'vs-icon vsphere-icon-datastore\': item.type === \'Datastore\', \
													\'vs-icon vsphere-icon-datacenter\': item.type === \'Datacenter\', \
													\'vs-icon vsphere-icon-cluster\': item.type === \'Cluster\', \
													\'vs-icon vsphere-icon-host-disconnected\': item.type === \'Host\' && item.object.power_state === \'POWERED_OFF\', \
													\'vs-icon vsphere-icon-host\': item.type === \'Host\' && item.object.power_state === \'POWERED_ON\', \
													\'vs-icon vsphere-icon-vm\': item.type === \'VirtualMachine\' && item.object.runtime.powerState === \'poweredOff\', \
													\'vs-icon vsphere-icon-vm-on\': item.type === \'VirtualMachine\' && item.object.runtime.powerState === \'poweredOn\', \
													\'vs-icon vsphere-icon-vm-suspended\': item.type === \'VirtualMachine\' && item.object.runtime.powerState === \'suspended\' \
												}"></i> \
												{{::item.title}}</th> \
											<td class="col-sm-3">{{::item.type}}</td> \
											<td class="col-sm-3">{{bwmC.getParentName(item.parent)}}</td> \
										</tr> \
									</tbody> \
								</table> \
					        </div> \
					    </div> \
					</div> \
					<div class="tab-pane" ng-if="bwmC.step == 3" ng-class="{\'active\': bwmC.step == 3}"> \
					  <hr class="hr-text" data-content="Backup repository"> \
					  <h5>Specify a backup repository to store the backup files produced by this job and configure a secondary destination</h5> \
						<form> \
							<div class="form-group row"> \
								<label for="backupName" class="col-sm-4 col-form-label">Backup repository</label> \
								<div class="col-sm-8"> \
									<select class="form-control" ng-model="bwmC.selectedPrimaryStorage">  \
										<option value="" selected>-- Select a backup repository --</option> \
										<option value="snapshot">NetApp Snapshot</option> \
									</select> \
								</div> \
							</div> \
							<div class="form-group row"> \
								<label for="backupName" class="col-sm-4 col-form-label">Restore points to keep</label> \
								<div class="col-sm-8"> \
									<input class="form-control" type="number" name="restorePoints" min="1" max="254" ng-model="bwmC.restorePoints"> \
								</div> \
							</div> \
							<div class="form-group row"> \
								<label for="backupName" class="col-sm-4 col-form-label">Backup to secondary target?</label> \
								<div class="col-sm-8"> \
									<switch class="pull-right" name="secondaryTarget" ng-model="bwmC.secondaryTarget" on="Yes" off="No"></switch> \
								</div> \
							</div> \
							<div class="form-group row" ng-if="bwmC.secondaryTarget"> \
								<hr class="hr-text" data-content="Secondary destination"> \
								<label for="backupName" class="col-sm-4 col-form-label">Secondary Target</label> \
								<div class="col-sm-8"> \
									<select class="form-control" ng-model="bwmC.selectedSecondaryTarget"> \
										<option value="" selected>-- Select a secondary target --</option> \
										<option value="snapmirror">NetApp SnapMirror</option> \
										<option value="snapvault">NetApp SnapVault</option> \
									</select> \
								</div> \
							</div> \
						</form> \
					</table> \
					</div> \
					<div class="tab-pane" ng-if="bwmC.step == 4" ng-class="{\'active\': bwmC.step == 4}"> \
						<hr class="hr-text" data-content="VM Quiesce"> \
						<div class="form-group"> \
						  <div class="col-sm-12"> \
							<input type="checkbox" name="quiesceTools" value="true" ng-model="bwmC.quiesceTools"> Enable VMware Tools quiescence\
						  </div> \
						  <p>To create transactionally consistent backups and replicas for VMs that do not support Microsoft VSS (for example, Linux VMs), you must enable VMware Tools quiescence for the job. It use the VMware Tools to freeze the file system and application data on the VM before backup or replication.</p> \
						</div> \
						<hr class="hr-text" data-content="Pre & Post Scripts"> \
						<div class="form-group"> \
							<div class="col-sm-12"> \
								<select class="form-control" ng-options="credential.uuid as credential.description + \' - \' + credential.username for credential in bwmC.credentials" ng-model="bwmC.credential"> \
								<option value="">-- Select Credential --</option> \
							</select> \
							</div> \
							<div class="col-sm-12"> \
								<small class="pull-left text-primary cursor-pointer" ng-click="bwmC.manageCredentials();">Manage Credentials</small> \
							</div> \
						</div> \
					</div> \
					<div class="tab-pane" ng-if="bwmC.step == 5" ng-class="{\'active\': bwmC.step == 5}"> \
						<hr class="hr-text" data-content="Backup schedule"> \
						<div class="form-group"> \
							<div class="col-sm-12"> \
								<input type="checkbox" name="backupNow" value="true" ng-model="bwmC.backupNow"> Run backup job now \
							</div> \
						</div> \
					</div> \
					<div class="clearfix"></div> \
				  </div> \
				  <div class="tab-pane" ng-if="bwmC.step == 56" ng-class="{\'active\': bwmC.step == 6}"> \
				  </div> \
				</form> \
			  </div> \
			</div> \
			<div class="modal-footer"> \
			  <button class="btn btn-primary" type="button" ng-if="bwmC.step == 1" ng-click="bwmC.step = 2">Next</button> \
			  <button class="btn btn-primary" type="button" ng-if="bwmC.step == 2" ng-click="bwmC.step = 3">Next</button> \
			  <button class="btn btn-primary" type="button" ng-if="bwmC.step == 3" ng-click="bwmC.step = 4">Next</button> \
			  <button class="btn btn-primary" type="button" ng-if="bwmC.step == 4" ng-click="bwmC.step = 5">Next</button> \
			  <button class="btn btn-primary" type="button" ng-if="bwmC.step == 5" ng-click="bwmC.step = 6">Next</button> \
			  <button class="btn btn-primary" type="button" ng-if="bwmC.step == 6" ng-click="bwmC.selectData()">Backup</button> \
			</div>'
		);

	}]);
}());

(function () {
    'use strict';
    backupsmApp.run(['$templateCache', function ($templateCache) {

        $templateCache.put('applications/backupsm/modals/ESXiSelectable.html',
            '<div class="modal-header"> \
              <div class="modal-title" id="modal-title">{{esmC.title}}</div> \
              <div class="window__controls window__controls--right"><a class="window__close" ng-click="esmC.close(); $event.stopPropagation();"><i class="fa fa-close"></i></a></div> \
            </div> \
            <div class="modal-body" id="modal-body"> \
              <hr class="hr-text" data-content="Select an ESXi host"> \
              <div class="form-group"> \
                <div class="col-sm-12"> \
                  <select class="form-control" ng-options="host as host.name for host in esmC.ESXihosts" ng-model="esmC.selectedHost"> \
                    <option value="">-- Select a managed ESXi host --</option> \
                  </select> \
                </div> \
              </div> \
            </div> \
            <div class="modal-footer"> \
              <button class="btn btn-primary" type="button" ng-click="esmC.selectESXihost()">Select</button> \
            </div>'
        );

    }]);
}());

(function () {
	'use strict';
	backupsmApp.run(['$templateCache', function ($templateCache) {

		$templateCache.put('applications/backupsm/modals/hierarchyItemsRenderer.html',
			'<div class="node-embed" ui-tree-handle ng-click="bwmC.itemSelect(item,this)"> \
			    <a class="btn btn-clear btn-xs" ng-if="::item.items.length" ng-click="bwmC.expandNode(this,$event)"> \
			        <i class="fa" ng-class="{\'fa-chevron-right p-r-xxs\': collapsed, \'fa-chevron-down\': !collapsed}"></i> \
			    </a> \
			    <span class="node-header" ng-class="::{\'p-l-27\': !item.items.length}"> \
			        <input type="checkbox" ng-disabled="::!bwmC.getLinkByVMwareDatastore(item)" ng-checked="item.isSelected" indeterminate-checkbox node="::item" /> \
			    </span> \
			    <i class="fa fa-exclamation text-warning" ng-if="::!bwmC.getLinkByVMwareDatastore(item) && item.type === \'VirtualMachine\'" uib-tooltip="This VM is not in a supported Storage"></i> \
			    <i class="fa fa-exclamation text-warning" ng-if="::!bwmC.getLinkByVMwareDatastore(item) && item.type === \'Datastore\'" uib-tooltip="This Datastore is not a supported Storage"></i> \
			    <i class="p-l-sm" ng-class="::{ \
			    \'vs-icon vsphere-icon-vcenter\': item.type === \'vCenter\', \
			    \'vs-icon vsphere-icon-datastore\': item.type === \'Datastore\', \
			    \'vs-icon vsphere-icon-datacenter\': item.type === \'Datacenter\', \
			    \'vs-icon vsphere-icon-cluster\': item.type === \'Cluster\', \
			    \'vs-icon vsphere-icon-host-disconnected\': item.type === \'Host\' && item.object.power_state === \'POWERED_OFF\', \
			    \'vs-icon vsphere-icon-host\': item.type === \'Host\' && item.object.power_state === \'POWERED_ON\', \
			    \'vs-icon vsphere-icon-vm\': item.type === \'VirtualMachine\' && item.object.runtime.powerState === \'poweredOff\', \
			    \'vs-icon vsphere-icon-vm-on\': item.type === \'VirtualMachine\' && item.object.runtime.powerState === \'poweredOn\', \
			    \'vs-icon vsphere-icon-vm-suspended\': item.type === \'VirtualMachine\' && item.object.runtime.powerState === \'suspended\' \
			    }"></i> {{::item.title}} \
			</div> \
			<ol ui-tree-nodes="" ng-model="item.items" ng-if="!collapsed"> \
				<li ng-repeat="item in ::item.items" ui-tree-node collapsed="true" ng-include="\'applications/backupsm/modals/hierarchyItemsRenderer.html\'"></li> \
			</ol>'
		);

	}]);
}());

(function () {
    'use strict';
    backupsmApp.run(['$templateCache', function ($templateCache) {

        $templateCache.put('applications/backupsm/modals/recoveryWizard.html',
            '<div class="modal-header"> \
              <div class="modal-title" id="modal-title">{{wmC.title}}</div> \
              <div class="window__controls window__controls--right"><a class="window__close" ng-click="wmC.close(); $event.stopPropagation();"><i class="fa fa-close"></i></a></div> \
            </div> \
            <div class="modal-body modal-recovery-wizard" id="modal-body"> \
              <div class="wizard"> \
                <ul class="nav nav-wizard"> \
                  <li ng-class="{\'active\': wmC.step == 1}"> \
                    <a ng-click="wmC.step = 1">SnapShot</a> \
                  </li> \
                  <li ng-class="{\'active\': wmC.step == 2}"> \
                    <a ng-click="wmC.step = 2">Recovery mode</a> \
                  </li> \
                  <li ng-class="{\'active\': wmC.step == 3}"> \
                    <a ng-click="wmC.step = 3">Destination</a> \
                  </li> \
                  <li ng-class="{\'active\': wmC.step == 4}"> \
                    <a ng-click="wmC.step = 4">Ready to apply</a> \
                  </li> \
                </ul> \
                <form> \
                  <div class="tab-content"> \
                    <div class="tab-pane" ng-if="wmC.step == 1" ng-class="{\'active\': wmC.step == 1}"> \
                      <hr class="hr-text" data-content="Select a backup Snapshot"> \
                      <table class="table table-hover m-t-xl"> \
                        <tbody> \
                          <tr class="cursor-pointer" ng-repeat="snapshot in wmC.data.snapshots"> \
                            <th class="col-sm-1"><input type="radio" name="snapshot" ng-model="wmC.data.snapshot" ng-value="snapshot[\'snapshot-instance-uuid\']" ng-disabled="snapshot.disabled"></th> \
                            <th class="col-sm-1">{{::snapshot.name}}</th> \
                          </tr> \
                        </tbody> \
                      </table> \
                    </div> \
                    <div class="tab-pane" ng-if="wmC.step == 2" ng-class="{\'active\': wmC.step == 2}"> \
                      <hr class="hr-text" data-content="Select a restore location"> \
                      <table class="table table-hover m-t-xl"> \
                       <tbody> \
                          <tr class="cursor-pointer" ng-if="!wmC.hideCurrentLocation"> \
                             <th class="col-sm-1"><input type="radio" name="restore" ng-model="wmC.restoreType" value="original"></th> \
                             <td class="lh-2"><h5>Restore to the original location</h5>Quickly initiate restore of selected VMs to the original location, and with the original name and settings. This option minimizes the chance of user input error.<br/><i class="fa fa-exclamation text-warning"></i> This virtual machine will be powered down during the restore process.</td> \
                          </tr> \
                          <tr class="cursor-pointer" ng-if="!wmC.hideNewLocation"> \
                             <th class="col-sm-1"><input type="radio" name="restore" ng-model="wmC.restoreType" value="new"></th> \
                             <td class="lh-2"><h5>Restore to a new location, or with different settings</h5>Customize restored VM location, and change its settings. The wizard will automatically populate all controls with the original VM settings as the default settings.</td> \
                          </tr> \
                       </tbody> \
                    </table> \
                    </div> \
                    <div class="tab-pane" ng-if="wmC.step == 3" ng-class="{\'active\': wmC.step == 3}"> \
                      <hr class="hr-text" data-content="Virtual Machine options"> \
                      <div ng-if="wmC.restoreType == \'new\'"> \
                        <div class="form-group"> \
                          <div class="col-sm-12"> \
                            <select class="form-control" ng-options="host as host.name for host in wmC.data.ESXihosts" ng-model="wmC.selectedHost" ng-change="wmC.loadESXidata()"> \
                              <option value="">-- Select a managed ESXi host --</option> \
                            </select> \
                          </div> \
                        </div> \
                        <div class="form-group"> \
                          <div class="col-sm-12"> \
                            <select class="form-control" ng-options="folder as folder.name for folder in wmC.data.folders" ng-model="wmC.selectedFolder"> \
                              <option value="">-- Select a VM folder --</option> \
                            </select> \
                          </div> \
                        </div> \
                        <div class="form-group"> \
                          <div class="col-sm-12"> \
                            <select class="form-control" ng-options="pool as pool.name for pool in wmC.data.resource_pools" ng-model="wmC.selectedPool"> \
                              <option value="">-- Select a Resource Pool --</option> \
                            </select> \
                          </div> \
                        </div> \
                        <div class="form-group"> \
                          <div class="col-sm-12"> \
                            <input class="form-control" type="text" placeholder="Select a VM name" ng-model="wmC.vmName" required> \
                          </div> \
                        </div> \
                        <div class="form-group"> \
                          <div class="col-sm-12"> \
                            Power ON VM \
                            <switch class="pull-right" name="powerON" ng-model="wmC.powerVM" on="on" off="off"></switch> \
                          </div> \
                        </div> \
                      </div> \
                      <div ng-if="wmC.restoreType == \'original\'"> \
                        <h5>This VM will be restored to same location as original VM.</h5> \
                        <h6><i class="fa fa-exclamation text-warning"></i> Original VM will be powered down during restore.</h6> \
                        <div class="form-group"> \
                            <div class="col-sm-12 p-m"> \
                                Power ON VM \
                                <switch class="pull-right" name="powerON" ng-model="wmC.powerVM" on="on" off="off"></switch> \
                            </div> \
                        </div> \
                      </div> \
                    </div> \
                    <div class="tab-pane" ng-if="wmC.step == 4" ng-class="{\'active\': wmC.step == 4}"> \
                      <hr class="hr-text" data-content="Summary"> \
                      <ul> \
                        <li>VM: {{wmC.data.vm.name}} from <strong>{{wmC.getSnapshotName()}}</strong></li> \
                        <li>Original Datastore: {{wmC.data.volume[\'volume-id-attributes\'].name}}</li> \
                        <li ng-if="wmC.restoreType == \'new\'">Host: {{wmC.selectedHost.name}}</li> \
                        <li ng-if="wmC.restoreType == \'original\'">Host: {{wmC.data.vm.runtime.host.name}}</li> \
                        <li>New VM name: {{wmC.vmName}}</li> \
                        <li>Power ON VM: {{wmC.powerVM}}</li> \
                      </ul> \
                      <p> \
                        After you click Restore, the selected VM will be instantly recovered into your production environment. To finalize the recovery use Storage VMotion to move running VM to the production storage.<br/> \
                        Alternatively, you can perform cold VM migration during your next maintenance window. \
                      </p> \
                      <p> \
                        If you are performing manual recovery testing, remember to change VM network to non-production before powering on the VM. \
                      </p> \
                    </div> \
                    <div class="clearfix"></div> \
                  </div> \
                </form> \
              </div> \
            </div> \
            <div class="modal-footer"> \
              <button class="btn btn-primary" type="button" ng-if="wmC.step == 1" ng-click="wmC.step = 2">Next</button> \
              <button class="btn btn-primary" type="button" ng-if="wmC.step == 2" ng-click="wmC.step = 3">Next</button> \
              <button class="btn btn-primary" type="button" ng-if="wmC.step == 3" ng-click="wmC.step = 4">Next</button> \
              <button class="btn btn-primary" type="button" ng-if="wmC.step == 4" ng-click="wmC.selectData()">Restore</button> \
            </div>'
        );

    }]);
}());

(function () {
    'use strict';
    backupsmApp.run(['$templateCache', function ($templateCache) {

        $templateCache.put('templates/applications/actions-backupsm.html',
            '<div class="window__actions" ng-controller="bmActionController as bmA"> \
              <a class="window__item"  title="New restore" ng-click="bmA.newRestore()"> \
                <i class="fa fa-plus text-success"></i> \
              </a> \
              <a class="window__item separator" ></a> \
            </div>'
        );

    }]);
}());
(function () {
    'use strict';
    backupsmApp.run(['$templateCache', function ($templateCache) {

        $templateCache.put('templates/applications/body-backupsm.html',
            '<div class="window__body" ng-controller="bmBodyController as bmB"> \
                <div class="window__side" ng-if="bmB.viewSide"> \
                    <uib-accordion> \
                        <div uib-accordion-group class="panel-success" is-open="true"> \
                            <uib-accordion-heading> \
                                <i class="fa m-t-f" ng-class="{\'fa-chevron-down\': $parent.isOpen, \'fa-chevron-right p-r-\': !$parent.isOpen}"></i> <i class="fa fa-server m-t-f"></i> Backup Jobs \
                            </uib-accordion-heading> \
                            <uib-accordion close-others="false"> \
                                <div class="menu__item" ng-repeat="backup in bmB.backups track by $index" ng-class="{\'active\': backup.uuid == bmB.active}" ng-click="bmB.setActive(backup)" ng-if="backup != undefined"> \
                                    <span class="p-l-xl"> \
                                        <h5>{{::backup.backup_name}}<br /></h5> \
                                    </span> \
                                </div> \
                            </uib-accordion> \
                        </div> \
                    </uib-accordion> \
                    <uib-accordion> \
                        <div uib-accordion-group class="panel-success" is-open="true"> \
                            <uib-accordion-heading> \
                                <i class="fa m-t-f" ng-class="{\'fa-chevron-down\': $parent.isOpen, \'fa-chevron-right p-r-\': !$parent.isOpen}"></i> <i class="fa fa-server m-t-f"></i> Restore Jobs \
                            </uib-accordion-heading> \
                            <uib-accordion close-others="false"> \
                                <div class="menu__item" ng-repeat="restore in bmB.restores track by $index" ng-class="{\'active\': restore.uuid == bmB.active}" ng-click="bmB.setActive(restore)" ng-if="restore != undefined"> \
                                    <span class="p-l-xl"> \
                                        <h5>{{::restore.restore_name}}<br /><small>{{::restore.snapshot}}</small></h5> \
                                    </span> \
                                </div> \
                            </uib-accordion> \
                        </div> \
                    </uib-accordion> \
                    <div class="secondary-content__new__box__toggle pointer visible-lg"> \
                        <div class="secondary-content__new__box__toggle__slide" ng-click="bmB.toggleSide()"> \
                            <i class="fa fa-arrow-left sidebar-open-font open-sidebar"></i> \
                        </div> \
                    </div> \
                </div> \
                <div class="secondary-content__new__box__toggle toggle_left pointer visible-lg" ng-if="!bmB.viewSide" ng-click="bmB.toggleSide()"> \
                    <i class="fa fa-arrow-right sidebar-open-font open-sidebar"></i> \
                </div> \
                <div class="window__main"> \
                    <div ng-if="bmB.showNewBackupType == true"> \
                        <div ng-include="\'templates/applications/new-backup-type-backupsm.html\'" include-replace></div> \
                    </div> \
                    <div ng-if="bmB.showRestore == true"> \
                        <div ng-include="\'templates/applications/restore-backupsm.html\'"></div> \
                    </div> \
                </div> \
            </div>'
        );

    }]);
}());
(function () {
    'use strict';
    backupsmApp.run(['$templateCache', function ($templateCache) {

        $templateCache.put('templates/applications/menu-backupsm.html',
            '<li> \
              <a > \
                <i class="menu__icon fa fa-search"></i> \
                Search \
              </a> \
            </li> \
            <li> \
              <a > \
                <i class="menu__icon fa fa-share-alt"></i> \
                Share \
              </a> \
            </li> \
            <li> \
              <a > \
                <i class="menu__icon fa fa-plug"></i> \
                Devices \
              </a> \
            </li> \
            <li class="divided"> \
              <a > \
                <i class="menu__icon fa fa-cog"></i> \
                Settings \
              </a> \
            </li>'
        );

    }]);
}());
(function () {
    'use strict';
    backupsmApp.run(['$templateCache', function ($templateCache) {

        $templateCache.put('templates/applications/new-backup-type-backupsm.html',
            '<div class="main_form"> \
              <p>Select which kind of Backup you want to perform</p> \
              <table class="table table-hover m-t-xl"> \
                <tbody> \
                  <tr class="cursor-pointer" ng-click="smB.newBackup(\'netapp\')"> \
                    <th class="col-sm-2 p-m"><img src="/img/netapp.png" width="75px"></th> \
                    <td class="lh-2">Creates a NetApp SnapShot with posterior SnapMirror or SnapVault</td> \
                  </tr> \
                  <tr class="cursor-pointer" ng-click="smB.newConnection(\'mariadb\')"> \
                    <th class="col-sm-2 p-m"><img src="/img/mariadb.png" width="75px"></th> \
                    <td class="lh-2">Creates a MySQL/MariaDB Database backup</td> \
                  </tr> \
                </tbody> \
              </table> \
            </div>'
        );

    }]);
}());

(function () {
    'use strict';
    backupsmApp.run(['$templateCache', function ($templateCache) {

        $templateCache.put('templates/applications/new-connection-type-backupsm.html',
            '<div class="main_form"> \
              <p>Select the type of server you want to register with managed infrastructure. All registred servers can be found under the Manager servers node on the Infrastructure tab.</p> \
              <table class="table table-hover m-t-xl"> \
              </table> \
            </div>'
        );

    }]);
}());
(function () {
    'use strict';
    backupsmApp.run(['$templateCache', function ($templateCache) {

        $templateCache.put('templates/applications/restore-backupsm.html',
            '{{bmB.getActive().type}} \
            Restore status: \
            <p ng-repeat="state in status">{{state}}</p> \
            <div ng-if="bmB.getActive().type == \'mount_restore_datastore\'"> \
                <div ng-if ="bmB.getActive().status[bmB.getActive().status.length - 1] == \'end\'"> \
                    <button class="btn btn-primary" type="button" ng-click="bmB.unpublishRestoredDatastore()">Stop Publishing Datastore</button> \
                    <button class="btn btn-primary" type="button" ng-click="bmB.openDatastoreBrowser()">Open Datastore Browser</button> \
                </div> \
                Restore status: {{bmB.getActive().status}} \
            </div> \
            <div ng-if="bmB.getActive().type == \'restore_datastore_files\'"> \
                <div ng-if ="bmB.getActive().status[bmB.getActive().status.length - 1] == \'end\'"> \
                    <button class="btn btn-primary" type="button" ng-click="bmB.unpublishRestoredDatastore()">Stop Publishing Datastore</button> \
                    <button class="btn btn-primary" type="button" ng-click="bmB.openDatastoreBrowser()">Open Datastore Browser</button> \
                </div> \
                Restore status: {{bmB.getActive().status}} \
            </div> \
            <div ng-if="bmB.getActive().type == \'restore_vm_guest_files\'"> \
                Restore status: {{bmB.getActive().status}} \
            </div> \
            <div ng-if="bmB.getActive().type == \'vm_instant_recovery\'"> \
                <div ng-if ="bmB.getActive().status[bmB.getActive().status.length - 1] == \'end\'"> \
                    <button class="btn btn-primary" type="button" ng-click="bmB.unpublishRestoredInstantVM()">Stop Publishing Instant VM</button> \
                    <button class="btn btn-primary" type="button" ng-click="bmB.migrateInstantVMtoProduction()">Migrate Instant VM to Production</button> \
                </div> \
                Restore status: {{bmB.getActive().status}} \
            </div>'
        );

    }]);
}());
